#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// Storage Classes,변수의 저장 공간 분류 요약 정리
// 지금까지 저장 공간의 다섯 가지 분류에 대해서 살펴 봤다. 
// 
// 저장 공간의 분류는 크게 두 가지로 나눌 수 있다. 
// 고정적이냐 vs. 아니냐
// 
// 저장 공간이 고정적인 것은 다시 세 가지로 분류할 수 있다. 
//	내부 연결, 외부 연결, 연결 없음
// 
// 고정적이라는 것은 메모리에 계속 자리를 잡고 있다, 객체가 계속 존재한다는 의미이다.
// 프로그램이 시작될 때 메모리에 올라가고, 프로그램이 종료될 때 사라진다. 
// 
// 초깃값을 미리 저장해 뒀을 경우에는 DATA segment에 올라간다. 
// 초깃값을 미리 저장해 두지 않고 선언만 했을 경우에는 BSS segment에 올라간다.
//	<- BSS segment에 올라가면 자동으로 0으로 초기화해 준다.
//	자동 변수, 지역 변수와는 달리 초기화를 해 주지 않아도 문제가 생기지는 않지만, 
//	static variables도 초기화를 해 주는 것이 좋다. 
// 
// 특히 외부 연결이 있어서, 여러 곳에서 사용하는 경우에는, 
// defining declaration과 referencing declaration이 구분된다. 
// defining declaration을 하는 곳에서 명확하게 초기화를 해 주는 것이 좋다. 
// 
// 자동 automatic은 블록 안이라는 scope를 갖는다.
//	프로그래머가 이 변수는 이 블록 안에서만 사용된다고 지정해 주는 것이다. 
// 이 영역에 들어오면 stack에 push를 해서 자리를 잡게 되고,
// 영역을 벗어나면 pop이 되면서 메모리에서 빠져나가게 된다. 
// 전체적인 메모리를 더 효율적으로 사용할 수 있게 된다. 
// 지속 기간이 자동으로 결정된다. 
// static variable과 달리 필요할 때만 메모리에 위치하게 된다. 
// stack 메모리에 있다가 없다가 해서 뭐가 있는지 확실하지가 않기 때문에, 
// linkage를 가질 수가 없다. 
// 선언 방법은 그냥 block 안에다가 하면 된다. 
// 지역 변수가 automatic variables에 해당된다. 
// 앞에다가 auto 키워드를 붙여줄 수도 있지만, 대부분 생략한다. 
// cf) C++에서는 auto 키워드가 완전히 다른 의미로 바뀌었다. 
// 
// 자동과 register의 차이는?
// 앞에다가 register를 붙이면, 컴파일할 때 가급적이면 
// register에 자리를 잡게 해 달라는 요청이 된다. 
// register는 cpu 안에 있는 작업 공간이기 때문에 더 빠르게 처리를 할 수 있다. 
// 실제로 register로 올라갈지는 미지수이다. 
// register에 들어가지 않았을 때는 stack에 들어가서 자동 변수처럼 작동한다. 
// register 키워드를 사용하면, 이것은 register로 올라갈 것으로 기대를 하는 것이므로,
// 주소를 가져올 수 없다. <- 주의 사항!
// 
// 자동 변수와 register 변수의 문법상 중요한 차이는?
// 주소를 가지고 올 수 있느냐 없느냐의 차이이다. 
// 
// 저장 공간 분류가, 고정적이고 연결 없음의 경우에는,
// 블록 안에서 static 키워드를 사용한다. 
// static 키워드의 의미는, 
// 첫째, 이 변수는 메모리에 (DATA 또는 BSS에) 처음부터 끝까지
// 고정적으로 존재하게 하라이다.  
// 둘째, 이 변수의 scope를 현재 영역에 고정시켜라이다. 
// 그래서 블록 안에서 선언을 한다. 
// 메모리에 위치하는 기간은 (duration은) 고정적으로 처음부터 끝까지이지만,
// visibility (볼 수 있는 영역)은 블록으로 한정돼 버린다. 
//	<= 이러한 이중적인 의미가 있다. 
// 주소를 찍어 보는 것은 가능하다. 메모리에 있기는 있기 때문이다.
// 다른 방법으로 우회해서 (포인터를 통해서) 접근하는 것이 가능하다. 
// 그러나, 이런 사용을 권장하지는 않는다. 
// 이렇게 사용하려면 고정적 내부 연결이나, 고정적 외부 연결을 사용하는 것이 좋다. 
// 
// 고정적 내부 연결 vs. 고정적 외부 연결
// 내부냐 외부냐의 기준이 중요하다. <= 번역 단위를 기준으로 한다.
// 컴파일러가 우리가 작성한 프로그램을 번역하는 단위 translation unit의 내부냐 외부냐.
// 번역 단위는 파일이다. 
// 컴파일러와 링커 강의를 복습하라.
// 
// 내부 연결 internal linkage는 파일 내부에서만 사용할 수 있다. 
// 모든 함수들 밖에서 static 키워드를 사용한다. 
// 
// 외부 연결 external linkage는 번역 단위의 외부로도 연결이 가능하다. 
// 외부에서 연결을 할 때는 외부에서 찾을 수 있도록 
// extern 키워드를 사용한다. 
// 
// 저장 분류 공간을 다섯 가지로 나누는 것에 대해 요약, 정리해 봤다. 
// 
// 동적 할당 메모리는 이어지는 강의에서 다룬다. // 
// 

int main() {


	return 0;
}