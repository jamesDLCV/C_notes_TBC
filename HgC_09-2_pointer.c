#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//$ 포인터 완전 정복을 위한 포인터 이해하기
// 
// C언어에서 포인터는 매우 중요하다. 
// 포인터의 필요성과 다양한 활용 방법을 알아 보자. 
// 
// 포인터는 주소를 저장하는 일정한 크기의 메모리 공간이다. 
// 따라서 언제든지 다른 주소를 저장하거나 포인터끼리 대입을 할 수 있다. 
// <= 포인터는 변수이므로 값을 언제든지 바꿀 수 있다. 
// 
// 그러나, 일반 변수와 달리 대입 연산에 엄격한 기준이 적용된다. 
// 
//$ 정리
// 포인터 - 주솟값 저장
//		 - 포인터끼리 대입 가능
//       - 대입 연산 기준 엄격

int main() {

	//$ 주소와 포인터의 차이
	// 
	// 주소는 변수에 할당된 메모리 저장 공간의 시작 주솟값 자체이고,
	// 포인터는 그 주솟값을 저장하고 있는 또 다른 메모리 공간이다. 
	// 
	// 따라서 특정 변수의 주솟값은 바뀌지 않지만, 
	// 포인터는 다른 주소를 대입하여 그 값을 바꿀 수 있다. 
	// 
	// 주소는 상수이고, 포인터는 변수이다. 
	{
		int a = 10, b = 20;					// 변수 선언과 초기화
		int* ptr;							// 포인터 선언

		ptr = &a;							// ptr이 a를 가리키도록 설정 
		ptr = &b;							// ptr이 b를 가리키도록 수정

		printf("ptr의 값은: %d\n", *ptr);	// 20
	}
	// 포인터 ptr에는 a의 주솟값을 넣어 줬다가 b의 주솟값으로 바꿀 수 있다. 
	// <= 가리키는 변수를 바꿀 수 있다. 주솟값을 저장할 변수를 바꿀 수 있다.
	//  
	// 변수 a와 변수 b의 주솟값은 선언 후 프로그램 실행 중에는 바뀌지 않는다.
	// 
	// 그러므로 주소는 상수이고, 포인터는 변수인 것이다. 
	// 
	// 따라서 두 개의 포인터가 같은 주소를 저장하는 일도 가능하다. 
	// 즉 하나의 변수의 주솟값을 두 개의 포인터가 가리키는 것도 가능하다. 
	{
		int a = 50;
		int* ptr_a, * ptr_b;		// int 형 포인터 선언
		ptr_a = ptr_b = &a;			// ptr_a와 ptr_b에 모두 a의 주솟값을 저장한다. 

		printf("\nptr_a = %d", *ptr_a);	// 50
		printf("\nptr_b = %d", *ptr_b);	// 50
		puts("");

		// 이 경우 a의 값을 바꾸거나 연산하는 데 ptr_a와 ptr_b를 모두 사용할 수 있다. 

		*ptr_a = 500;				// ptr_a를 간접 참조하여 값을 수정했다. 그러면,

		printf("\nptr_a\t= %d", *ptr_a);	// 500
		printf("\nptr_b\t= %d", *ptr_b);	// 500, *ptr_b의 값도 바뀌고,
		printf("\na\t= %d", a);				// 500, a 값도 바뀜. 
	}
	// 주소도 포인터처럼 간접 참조 연산자를 쓸 수 있지만 상수이므로 대입 연산자 왼쪽에 올 수는 없다.
	// 즉 상수와 변수는, 용도가 분명히 다르므로 주소와 포인터는 서로 구분해서 이해하라. 
	// 
	// &a = &b;	
	// <= 이처럼 a의 주소를 b의 주소로 바꾸는 것은 불가능하다. !!!
	puts("\n");

	//$ 주소와 포인터의 크기 
	// 포인터도 저장 공간이므로 크기 있다. 
	// 포인터의 크기는 저장할 주소의 크기에 따라 결정된다. 
	// 크기가 클수록 더 넓은 범위의 메모리를 사용할 수 있다. 
	// 
	// 포인터의 크기는 컴파일러에 따라 다를 수 있으나, 
	// 모든 주소와 포인터는, 가리키는 자료형과 상관 없이 그 크기가 같다. !!!
	{
		// 주소와 포인터의 크기
		char	ch;
		int		in;
		double	db;

		char* ptr_ch = &ch;
		int* ptr_in = &in;
		double* ptr_db = &db;

		printf("char   형 변수의 주소 크기:\t%u\n", sizeof(&ch));	// x86: 4, x64: 8
		printf("int    형 변수의 주소 크기:\t%d\n", sizeof(&in)); // x86: 4, x64: 8
		printf("double 형 변수의 주소 크기:\t%d\n", sizeof(&db)); // x86: 4, x64: 8
		// <= 각 변수의 주소를 구해서 크기를 출력하는 문장이다. 
		// ch, in, db는 각각 변수 자체의 크기는 다르지만, 그 시작 주숫값의 크기는 모두 동일하다.
		puts("\n");

		printf("char   형 * 포인터의 주소 크기:\t%d\n", sizeof(ptr_ch)); // x86: 4, x64: 8
		printf("int    형 * 포인터의 주소 크기:\t%d\n", sizeof(ptr_in)); // x86: 4, x64: 8
		printf("double 형 * 포인터의 주소 크기:\t%d\n", sizeof(ptr_db)); // x86: 4, x64: 8
		// 마찬가지로 포인터도 가리키는 자료형과 상관 없이 모두 크기가 동일하다. 
		puts("\n");

		printf("char   형 * 포인터가 가리키는 변수의 크기:\t%d\n", sizeof(*ptr_ch)); // 1
		printf("int    형 * 포인터가 가리키는 변수의 크기:\t%d\n", sizeof(*ptr_in)); // 4
		printf("double 형 * 포인터가 가리키는 변수의 크기:\t%d\n", sizeof(*ptr_db)); // 8
		// <= 포인터가 가리키는 변수의 크기는 x86과 x64에소 모두 동일하다. 
		// 포인터에 간접 참조 연산자를 사용하여 가리키는 변수의 크기를 출력하면, 
		// 각각 다른 결과가 나온다. 

		// ptr_ch  |0x100|  ---> 100 | ch
		// ptr_in  |0x200|  ---> 200 | 201 | 202 | 203 | in
		// ptr_db  |0x400|  ---> 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | db
		//         포인터의             가리키는 변수의 크기는 다르다. 
		//        크기는 같다
		puts("\n");

		printf("char   형의 크기:\t%d\n", sizeof(char));		// 1
		printf("int    형의 크기:\t%d\n", sizeof(int));		// 4
		printf("double 형의 크기:\t%d\n", sizeof(double));	// 8

	}
	// 주소의 크기는		자료형과 관계 없이 동일하다. !!!
	// 자료형의 크기는		자료형에 따라 다르다. 
	// 변수의 크기도		자료형에 따라 다르다. 
	puts("\n");


	//$ 포인터의 대입 규칙
	// 포인터는 크기가 모두 같지만 대입 연산을 할 때는, 다음의 규칙에 따라 제한적으로 사용해야 한다.
	// 
	// 규칙 1. 포인터는 가리키는 변수의 형태가 같을 때만 대입해야 한다. 
	//        포인터끼리의 대입 연산을 통해서 여러 개의 포인터로 같은 데이터를 다루는 것이 가능하다.
	//        그러나 규칙을 지키지 않는 대입 연산을 하면 그 결과를 예상할 수 없다. 
	{
		int a = 10;
		int* ptr_a = &a;
		double* ptr_db;

		ptr_db = ptr_a;				// 포인터 ptr_a 값을 포인터 ptr_db에 대입
		printf("%lf\n", *ptr_db);
	}
	// -92559592117432107884277659021957555520241347761778250032873472.000000
	// 이상한 값이 포인터 ptr_db에 들어 있다. 
	// 컴파일러는 ptr_a에 저장된 값을 int 형 변수의 주소로 생각하고, 
	// ptr_db에 저장된 값을 double 형 변수의 주소로 생각한다. 
	// 
	// 따라서 ptr_db에 ptr_a를 대입한 후에 간접 참조 연산을 수행하면, 
	// 변수 a에 할당된 영역 이후의 할당되지 않은 영역까지 사용하게 된다. 
	// 
	//                     <------ ptr_a ----->  
	// ptr_a   |100| ----> |        10         |
	// ptr_db  |100| ----> |        10         |    |    |    |    |
	//                     100  101  102  103  104  105  106  107
	//                     <--------------- ptr_db ----------------> 
	//                                    <---- 알 수 없는 값--->
	// ptr_db를 통해 간접 참조 연산을 수행하면, 
	// 메모리 100번지부터 107번지까지 8바이트를 하나의 double 형 변수로 간주하고,
	// 그 안에 있는 값을 실수 값으로 해석하므로, 알 수 없는 결괏값을 출력한다. 
	//
	// 104번지 107번지까지가 다른 변수에 할당되어 이미 사용되고 있는 경우에는,
	// *ptr_db를 대입 연산자 왼쪽에 사용하면, 그 변수의 값이 바뀌게 된다. !!!!!
	// 
	// 가리키는 자료형이 일치하지 않는 포인터의 대입을 시도하면, 
	// 컴파일러는 다음과 같은 경고 메시지를 보낸다. 
	// warning C4133: '=': incompatible types - from 'int *' to 'double *'
	//
	{
		double db = 10;
		double* ptr_db = &db;
		int* ptr_a;

		ptr_a = ptr_db;				// 포인터 ptr_db 값을 포인터 ptr_a에 대입
		printf("%d\n", *ptr_a);		// 0 
	}
	// 이렇게 double 형 포인터를 int 형 포인터에 대입해도 결괏값이 제대로 나오지 않는다. 
	//  warning C4133: '=': incompatible types - from 'double *' to 'int *'
	// 
	// 
	// 규칙 2. 형 변환을 사용한 포인터의 대입은 언제나 가능하다. 
	// 포인터가 가리키는 자료형이 다른 경우라도 형 변환 연산자를 사용하면, 
	// 경고 메시지 없이 대입할 수 있다. 
	// 물론 대입한 후에 포인터를 통한 사용에 문제가 없어야 한다.  
	{
		double a = 3.4;				// double 형 변수 선언
		double* ptr_d = &a;			// ptr_d가 double 형 변수 a를 가리키도록 초기화

		int* ptr_i;					// ptr_i 형 변수를 가리키는 포인터
		ptr_i = (int*)ptr_d;		// ptr_db 값을 형 변환하여 ptr_in에 대입

		printf("\n*ptr_in = %f\n", *ptr_i);	// 0.000000, 왜 이런 숫자가 나오지?

	}
	// 여기서 ptr_i에 간접 참조 연산을 수행하면, 변수 a의 일부를 int형 변수처럼 사용할 수 있다. 
	// 이런 방법은 포인터로 메모리를 직접 쪼개 쓰는 것이므로 데이터가 메모리에 저장되는 방식을 
	// 충분히 이해하고 있어야 한다. 
	// 
	// 만약 *ptr_i  = 10;과 같이 a의 일부분에 정수를 저장하면, 
	// 정수와 실수의 데이터 크기와 저장 방식이 다르므로 a에 저장한 실수 값은 사용할 수 없다. 
	// 
	//                        <-------- 변수 a와 *ptr_d의 영역 -------->
	//                        100  101  102  103  104  105  106  107  
	// ptr_d    | 100 | ----> |    |    |    |    |    |    |    |    | a
	// ptr_i    | 100 | ----> |    |    |    |    |    |    |    |    |
	//                        <------------------->
	//                        *ptr_i가 사용하는 영역
	//
	// <= double 형 포인터 ptr_d를 int로 형변환해서 int 형 포인터 ptr_i에 넣어주면, 
	//    오류를 발생하지 않으나, double 형의 값이 int로 제대로 들어가지는 않는다. 
	// 
	// int 형 포인터를 double 형 포인터에 넣으면, 
	{
		int a = 3;				// double 형 변수 선언
		int* ptr_i = &a;			// ptr_d가 double 형 변수 a를 가리키도록 초기화

		int* ptr_d;					// ptr_i 형 변수를 가리키는 포인터
		ptr_d = (int*)ptr_i;		// ptr_db 값을 형 변환하여 ptr_in에 대입

		printf("\n*ptr_d = %d\n", *ptr_d);	// 3, int 형 값이 double 형 포인터로 들어갔다.
	}
	// 
	// 포인터에 100번지를 직접 대입하는 것은 가능할까?
	// 형 변환 연산자를 사용하면, 컴파일 경고나 에러 없이, 
	// 원하는 정수 값을 포인터에 대입하여 사용할 수 있다. 
	// 
	// 예를 들어, 100번지부터 103번지까지 4바이트의 메모리 공간을 int 형 변수로 쓰고 싶다면, 
	// 다음과 같이 포인터를 사용하면 된다 
	/*
	{
		int* ptr;
		ptr = (int*)100;	// 100을 int 형 변수의 주소로 형 변환하여 ptr에 대입
		*ptr = 10;			// 100번지부터 103번지까지 4바이트의 공간에 10을 대입
	}
	*/
	// <= 이 문장은 컴파일 과정에서 전혀 문제될 것이 없다. 
	//    그러나 메모리 100번지부터 103번지까지가 어떤 용도로 사용되는 영역인지 알 수 없으므로,
	//    프로그램을 실행할 때 문제를 일으킬 가능서이 크다. 
	//    <= 실제로 내 visual studio에서는, 이렇게 써 주면, 이부분에서 자동 종료된다. 
	// 
	// 따라서 포인터는 항상 정상적으로 할당 받은 메모리 공간의 주소를 저장해서 사용해야 한다. 
	// 
	// 같은 이유로 포인터를 초기화하지 않는 건 더 위험하다. 
	// 이 경우 포인터에 간접 참조 연산을 수행하면, 알 수 없는 곳으로 찾아가 데이터를 바꾼다. 
	/*
	{
		int* p;
		*p = 10;				 <= 이렇게 초기화 없이 사용하면 안 된다.

		printf("%d %d", *p, p);
	}
	*/
	// 포인터를 초기화하지 않고 사용하면, 
	// <= Error	C4700	uninitialized local variable 'p' used	
	//    이라는 에러 메시지가 뜬다. 
	//    
	// 
	// 아래는 포인터 복습이다. 
	{
		int a = 10;
		int* p;
		p = &a;

		*p = 10;

		printf("\n%d %d %d %d %d\n", *p, p, &p, &a, a);
		// 10 68154852 68154888 10 68154852
	}
	// p는 &a이다. 즉 p는 a의 주소이다. <= 맞나? 
	// &p는 p 자체의 주소이다. a와는 아무런 관계가 없다. <= 맞나?

	//$ 포인터를 사용하는 이유
	// 변수를 사용하는 가장 쉬운 방법은, 이름을 쓰는 것이다. 
	// (계속)

	return 0;
}