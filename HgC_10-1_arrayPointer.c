#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// 10-1. 배열과 포인터의 관계
// 배열의 데이터를 자유롭게 다루기 위해서는 배열의 구현 원리를 이해할 필요가 있다. 
// 배열과 포인터의 관계를 밝히고, 포인터로 배열을 사용하는 방법을 살펴 본다.

int main() {

	// 배열은 자료형이 같은 변수를 메모리에 연속으로 할당한다. <= 같은 자료형의 변수!!!
	// 따라서 각 배열 요소는 일정한 간격으로 주소를 갖게 된다. 
	// 
	// int arr[5];의 배열이 메모리 100번지부터 할당되고, 
	// int 형 변수의 크기가 4바이트라면, 
	// 각 배열 요소의 주소는 100, 104, 108, 112, 116번지가 된다. 
	// 
	// 배열 요소의 주소    100     104     108     112     116
	// 배열명 arr         |       |       |       |       |       |  
	// 배열 요소          arr[0]  arr[1]  arr[2]  arr[3]  arr[4]  
	//
	// 첫 번째 요소의 주소를 알면 나머지 요소의 주소도 쉽게 알 수 있고,
	// 각 주소에 간접 참조 연산을 수행하면, 모든 배열 요소를 사용할 수 있다. 
	// 
	// 따라서 컴파일러는 첫 번째 배열 요소의 주소를 쉽게 사용하기 위해서,
	// 컴파일 과정에서 배열명을 첫 번째 배열 요소의 주소로 변경한다.                  !!!!!
	// 
	//$ 정리
	//  배열명은 첫 번째 배열 요소의 주솟값
	//  배열명은 첫 번째 배열 요소를 가리킨다. 
	//  *arr는 첫 번째 배열 요소이다. 
	//
	//$ 배열명으로 배열 요소 사용하기
	// 주소는 정수처럼 보이지만 자료형에 대한 정보를 갖고 있는 특별한 값이다. 
	// 따라서 자유로운 연산은 할 수 없고, 정해진 연산만 가능하다. 
	// 정수 덧셈이 대표적인데, 다음과 같은 독특한 방식으로 수행된다. 
	//
	// 주소 + 정수 ----> 주소 + (정수 * 주소를 구한 변수의 크기)                   !!!!!
	// 
	// 예) 크기가 4바이트인 int 형 변수 a의 주소 100번지에 1을 더한 결과는?
	//    <= 104가 된다. 
	//       100 + (1 * 4)   <= 주소 + (정수 * 자료형의 크기)
	//       101이 아니다. 
	// 
	//            100  101  102  103   
	// 변수 a      |    |    |    |    | 
	// 
	//     &a      a의 주솟값 (100번지).
	//             a를 가리킨다. 
	//             int 형을 가리킨다 (a가 int 형이므로).
	// 
	//     &a + 1  ----> 100 + (1 * sizeof(int)) ----> 104
	//             int 형을 가리키는 주소 104번지
	//             104번지부터 107번지까지 4바이트 저장 공간의 주솟값
	// 
	// 이런 연산 규치은 배열을 사용할 때 유용하다.
	// 
	// 배열명도 주소이므로 정수를 차례로 더하면 연속된 배열 요소의 주소를 구할 수 있고,
	// 여기에 간접 참조 연산을 수행하면, 모든 배열 요소를 사용할 수 있다. 
	// 
	// 배열명을 주소로 활용하는 예를 살펴 보자.
	{
		// 배열명에 정수 연산을 수행하여 배열 요소 사용
		int arr[3];
		int i;

		*(arr + 0) = 10;				// arr[0] = 10
		*(arr + 1) = *(arr + 0) + 10;	// arr[1] = arr[0] + 10

		printf("세 번째 배열 요소에 키보드 입력: ");

		int input = scanf("%d", arr + 2);  // warning 파란줄이 떠서 input에 넣어 줌

		for (int i = 0; i < 3; ++i) {
			printf("%5d", *(arr + i));	// arr[i]
		}
	}
	// 출력)
	// 세 번째 배열 요소에 키보드 입력: 30
	//      10   20   30
	// 
	//            100  101  102  103  104  105  106  107  108  109  110  111
	// 배열명 arr  |    |    |    |    |    |    |    |    |    |    |    |
	//            arr[0]              arr[1]              arr[2]
	// 
	// 배열명은 첫 번째 배열 요소의 주소이므로, 배열명의 주솟값은 100이다. 
	// (arr + 0)는 첫 번재 배열 요소의 주소이므로 100이다. 
	// 
	// (arr + 0)에 간접 참조 연산을 수행하면, 첫 번째 배열 요소 자체가 된다. 
	// <= *arr와 동일하다. 
	// <= arr[0]과도 동일하다. 
	// 
	// *(arr + 0) == *arr == arr[0]                                        !!!!!
	// 
	// (arr + 1)은 두 번째 배열 요소의 주소가 된다. <= 104번지
	// *(arr + 1)와 같이 간접 참조 연산을 수행하면, 두 번째 배열 요소를 사용할 수 있다.
	// 
	// *(arr + 1) == arr[1] 
	// 
	// *(arr + 1) = *(arr + 0) + 10;                                  
	//     arr[1] = arr[0]     + 10;   <= 이 둘은 동일한 연산을 수행한다. 
	// 
	// <= 첫 번째 배열 요소의 값에 10을 더해서 두 번째 배열 요소에 저장한다. 
	//
	// scanf("%d", arr + 2)
	// scanf("%d", &arr[2]);           <= 이 둘은 동일하다. 
	// 
	// arr + 2 == &arr[2]
	// 
	// <= 세 번째 배열 요소의 값을 키도드로 입력 받는다.  
	//
	// 배열의 대괄호 []는 포인터 연산의 '간접 참조, 괄호, 더하기' 연산 기능을 갖느다. 
	// <= 배열 요소에 사용하는 대괄호는 연산식이다. 
	// 
	// 배열 요소 표현식             포인터 연산식 
	//     arr[1]      <---->      *(arr + 1)                              !!!!!
	// 
	// 배열 요소를 사용할 때는 상황에 따라 대괄호나 포인터 연산식 중 적당한 것을 
	// 골라 쓰면 된다. 특별한 경우가 아니면, 대괄호를 쓰는 것이 쉽다. 
	// 
	// &arr[2]와 같은 경우는, arr + 2로 쓰면 연산 과정을 줄일 수 있다. 
	// 
	//$ 배열의 할당 영역을 벗어나는 포인터 연산식은 사용할 수 있는가?
	// 
	// 사용할 수 있으나 사용하면 안 된다.                                      !!!!!
	// 문법적으로 문제가 없으므로 컴파일은 되지만, 실행할 때 결과를 예상할 수 없게 된다. 
	// 
	// eg) 배열 요수의 개수가 3인 arr 배열에서,
	//     (arr + 3)은 네 번째 배열 요소의 주소가 되고, 
	//     *(arr + 3)은 네 번째 배열 요소가 된다. 
	// 
	//           arr + 0  arr + 1  arr + 2  arr + 3
	// arr 배열  |        |        |        |    ?   | 
	//           arr[0]   arr[1]   arr[2]   arr[3]
	// 
	// 네 번째 배열 요소는 arr 배열에 할당된 영역이 아니므로, 사용하면 안 된다. 
	// 만약 그 영역이 다른 변수나 배열에 할당되어 있다면, 그 값이 바뀔 수도 있고, 
	// 운영체제가 관리하는 영역이라면, 프로그램이 강제 종료될 수도 있다. 
	// 
	// arr[3]의 배열 요소 표현식도 결국 포인터 연산식으로 바뀌므로, 
	// 마찬가지로 사용할 때 주의해야 한다. 

	return 0;
}
