#include <stdio.h>
// 문자열을 정의하는 방법
// 문자열 문법과 유용하게 사용할 수 있는 함수 소개
// 문자열을 정의하는 방법
// 문자열의 마지막 널 캐릭터
// 사이즈가 정해진 문자열의 경우 컴파일러가 '\0'을 채워주기도 한다. 
// 메모리와 관련지어서 살펴 볼 것이 있다. 

#define MESSAGE "A symbolic string constant"
    // 문자열도 symbolic constant로 만들 수 있다. 
    // 매크로처럼 정의를 할 수도 있다. 
#define MAXLENGTH 81

int main() {

    // 문자열을 선언하는 방법 세 가지
    // 1. 문자열 자체를 선언한다.
    // 2. 배열로 만든다. 
    // 3. 문자열에 대한 포인터로 선언한다. 

    char words[MAXLENGTH] = "A string in an array";
    // 메모리에 배치되는 구조 때문에, 배열을 만들게 되는데 
    // 이때는 여러 글자가 나열돼 있는 것이다. 
    // char 타입의 배열이 된다. 
    // 매번 사용하고자 하는 문자열의 개수를 세는 것이 어렵다. 
    // 위처럼 넉넉한 배열의 길이를 만드는 게 일반적이다. 
    // 넉넉한 사이즈를 주고 문자열을 집어 넣는다.  
    // 이것이 일반적인 c-style 문자열 초기화 방법이다.
    // 이 배열은 배열 자체가 메모리 공간을 가지고 있다. 
    // words라는 배열의 이름으로, 
    // MAXLENGTH * char 만큼 사이즈의 메모리 공간을 가지고 있다. 
    // "A string in an array"이 자기가 갖고 있는 메모리 공간에 
    // 저장이 되는 것이다. 
    // 21개의 글자가 있다. '\0' 포함이다.
    // 
    // 그렇다면 포인터는??????  

    const char* pt1 = "A pointer to a string.";
    // 문자열에 대한 포인터를 선언할 수도 있다. 
    // pt1은 이 문자열이 메모리에 실제로 저장돼 있는 긴 공간의
    // 첫 번째 주소를 가리킨다. 
    // 포인터만 가지고 있는 문자열이다. 
    // 포인터는 어딘가에 저장이 돼 있는 것의 첫 번재 주소만 가지고 온다.

    puts("Puts() adds a newline at the end:"); // puts() add \n at the end
    // 문자열 자체를 문자열 리터럴(상수)로 만들어서 함수에 바로 넣어 버린다.  
    // puts 함수는 문자열을 출력해 준다. 
    // 마우스를 갖다 대면, 문자열의 포인터 하나를 받아들이고 있다는 것을 알 수 있다.  
    // 문자열이 배열의 일종처럼 메모리에 배치가 돼 있다.
    // 함수에 전달할 때는, 첫 번째 주소를 포인터로 넘겨 줄 수 있다. 


    puts(MESSAGE);
    // puts 같이 문자열을 사용하는 함수들은, 
    // 이것이 문자열이라고 생각을 할 때는, 
    // 마지막에 숨어 있는 널 캐릭터를 찾을 때까지, 
    // 문자를 쫙 읽어 나간다. 

    puts(words);    // char words[21] removes this warning
        // 일반적인 경우다. 배열로 저장돼 있는 문자열을 출력한다. 
        // 문자열은 words가 가지고 있는 메모리에 저장이 된다. 
        // words는 MAXLENGTH만큼의 자신만의 메모리 공간을 가지고 있다. 
        // 마우스를 words에 갖다 대면, Using uninitialized memory 'words'
        // 라는 메시지가 뜬다. 초기화가 되지 않은 메모리를 사용하고 있다고
        // 경고하고 있다. 
        // words로 가 보면 분명히 초기화하고 있다. 
        // 그런데 왜 warning이 뜰까?
        // MAXLENGTH만큼의 공간을 전부 초기화한 게 아니다. 
        // 마우스를 MAXLENGTH에 갖다대면 null character까지 포함해서
        // 21개이다(?) (6:40). 21개 안 나오고 81개가 뜬다. 확인해 봐라. 
        // visual studio에서는 words에 Waring을 띄워준다. 
        // uninitialised memory 'words'
        // 
        // 초기화가 되지 않은 메모리를 사용하므로 Warning을 운다.   
        // <== 엇? 위로 가서 보면, 분명히 초기화를 하고 있다. 
        // 이 배열의 사이즈는 char 타입 81개이나 
        // 초기화가 된 것은 21개밖에 안 되므로, 
        // 60개가 초기화가 안 됐다고 경고를 해 주는 것이다. 
        // 친절한 경고이기도 하지만 c-style에 익숙한 사람들에게는 
        // 번거로울 수 있다. 개발 환경 입장에서는 경고를 해 주는 게 맞겠다.
        // 배열의 사이즈를 21개로 맞춰 주면 Warning은 사라진다. 

    puts(pt1);
    // 이렇게 포인터만 가지고 있는 문자열에 대한 포인터를 
    // puts() 함수로 출력한다. 
    // 포인터 pt1은 어딘가에 저장돼 있는 것의 
    // 첫 번째 주소만 가지고 온 것이다. 
    // puts(words);나 puts(pt1);은 동일하게 작동한다. 

// 배열과 포인터의 성질 차이에 대해서는 앞 강의에서 여러 번 언급했다. 
// 그 성질이 똑같이 적용된다. 
// 이 차이에 대해서는 다음 강의에서 더 자세하게 소개된다. 
// 일단은 문접적으로 어떻게 차이가 나는지부터 가볍게 한번 봐라.

// puts 함수는 C의 여러 문자열 관련 함수 중 하나이다. 
// puts 함수는 맨 끝에 \n (new line)을 덧붙여 준다.
// 좀 더 편하게 사용할 수가 있다. 

// 아래는 조금 민감할 수 있다. 
    words[3] = 'p'; // OK, 교체가 잘 된다. 
                    // 't' -> 'p'
                    // words는 결국 배열인 것이다. 
                    // 배열이므로 특정 원소에 접근을 해서 바꿀 수 있다. 
    puts(words);


    //pt1[8] = 'A'; // Error
                    // pt1은 교체를 할 수 없다. 
                    // const를 붙여줘서인가?
                    // const를 떼더라도 런타임 에러가 발생한다. 
                    // exited with code -1073741819.
        // 런타임 에러는 아주 골치 아픈 존재이다. 
        // pt1[8]이 건드리면 안 될 곳을 건드린 것이다. 
        // string 사용할 때 주의해야 할 점 중 하나이다. 
        // 그러한 이유로 포인터만으로 string을 정의하는 경우에는, 
        // const를 붙여 주는 것이 좋다. 

    char greeting[50] = "Hello, and"" How are " "you";


    return 0;
}

// (예습) 
// 읽기 전용 메모리에 저장된 데이터의 값을 바꾸려고 시도하면
// 운영체제가 중단시킨다. 
// 배열은 읽기/쓰기가 모두 가능한 메모리를 사용한다. 
// 문자열 리터럴은 프로그램의 일부이기 때문에
// 읽기 전용 메모리에 저장되어 있다. 