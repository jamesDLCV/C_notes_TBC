#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//$ 여러 가지 포인터 사용해 보기
// 포인터가 어떤 변수를 가리키게 되면(어떤 변수의 주소를 저장하게 되면),
// 그 이후에는 간접 참조 연산자를 통해 가리키는 변수를 자유롭게 쓸 수 있다. 

int main() {

	{
		// 포인터를 사용한 두 정수의 합과 평균 계산
		int a = 10, b = 15, total;	//.변수 선언과 초기	
		double avg;					// 평균을 저장할 변수 

		int* ptr_a, * ptr_b;		// 포인터 선언
		ptr_a = &a;					// 포인터 ptr_a에 a의 주소 대입
		ptr_b = &b;					// 포인터 ptr_b에 b의 주소 대입

		int* ptr_t = &total;		// 포인터 ptr_t의 선언과 초기화
		double* ptr_g = &avg;		// double 형 포인터 ptr_g의 선언과 초기화

		*ptr_t = *ptr_a + *ptr_b;	// a 값과 b 값을 더해서 total에 저장
		*ptr_g = *ptr_t / 2.0;		// total 값을 2로 나눈 값을 avg에 저장

		printf("두 정수의 값:\t%d, %d\n", *ptr_a, *ptr_b);	// a 값과 b 값 출	력
		printf("두 정수의 합:\t%d\n", *ptr_t);				// total 값 출력
		printf("두 정수의 평균:\t%.1lf\n", *ptr_g);			// avg 값 출력
	}

	// int* ptr_a, * ptr_b;	<= 포인터를 연속으로 선언할 수 있다. 
	//						   콤마를 사용하여 한 번에 선언할 때는, 
	//                         * asterisk를 변수마다 붙여야 한다. 
	// 
	// int* ptr_a, ptr_b;	<= 이렇게 선언하면, ptr_a는 포인터로 선언이 되지만, 
	//                         ptr_b는 일반 변수로 선언이 된다. 
	// 
	// 포인터 선언과 초기화는 다음 두 가지 방법이 있다. 
	// 1.
	// int* ptr_t;			// 포인터 선언
	// ptr_t = &total;		// 주소를 구해 저장
	// 
	// 2.
	// int* ptr_t = &total;	// 포인터 선언과 동시에 주소로 초기화
	// 
	// 포인터는 가리키는 변수의 자료형과 동일하게 선언한다. 
	// 
	// double* ptr_g = &avg;
	// <= 포인터 ptr_g는 avg의 주소를 가리키므로(저장하므로), 
	//	  가리키는 자로형은 avg와 동일한 double을 사용한다. 
	// 
	// 변수 a의     메모리 시작 주솟값이 100이라면, 포인터 ptr_a에는     100이 저장된다. 
	// 변수 b의     메모리 시작 주솟값이 200이라면, 포인터 ptr_b에는     200이 저장된다.
	// 변수 total의 메모리 시작 주솟값이 300이라면, 포인터 ptr_total에는 300이 저장된다. 
	// 변수 avg의   메모리 시작 주솟값이 400이라면, 포인터 ptr_avg에는   400이 저장된다. 
	// 
	// 이후부터는 포인터에 간접 참조 연산자를 사용하여 가리키는 변수를 사용할 수 있다. 
	// *ptr_t는 포인터 ptr_t가 가리키는 변수 total이 된다.   
	// *ptr_a는 a, 
	// *ptr_b는 b가 된다. 
	// 
	// 따라서, 
	// *ptr_t = *ptr_a + *ptr_b;	<= a 값과 b 값을 더해서 total에 저장한다. 
	// 
	// 일반 변수를 a, b, total, avg와 같은 이름으로 사용할 수 있고, 
	// 그 변수들을 가리키는 포인터를 간접 참조해도 사용할 수 있다. 

	//$ const를 사용한 포인터 
	// const 예약어를 포인터에 사용하면, 이는 가리키는 변수의 값을 바꿀 수 없다는 의미로,
	// 변수에 사용하는 것과는 다른 의미를 가진다. 
	{
		// 포인터에 const 사용
		int a = 10, b = 20;
		const int* ptr_a = &a;				// 포인터 ptr_a는 변수 a를 가리킨다. 

		printf("\n변수 a 값: %d", *ptr_a);	// 10, 포인터를 간접 참조하여 a 출력
		ptr_a = &b;							// 포인터 ptr_a가 변수 b를 가리키게 한다.

		printf("\n변수 b 값: %d", *ptr_a);	// 20, 포인터 ptr_a를 간접 참조하여 b 값 출력

		ptr_a = &a;							// 포인터 ptr_a가 다시 변수 a를 가리킨다. 
		a = 30;								// a를 직접 참조하여 값을 바꾼다. 

		//*ptr_a = 30;						// 간접 참조로 a의 값을 바꿀 수 없다. 
											// 포인터를 선언할 때 const를 붙였기 때문이다. 

		printf("\n변수 a 값: %d", *ptr_a);	// 30, 포인터 ptr_a로 간접 참조하여 바뀐 값 출력
											// *ptr_a의 값이 바뀌었다. !!!!!
	}
	printf("\n");
	// 위 예제에서 ptr_a를 선언할 때, const로 상수화했다. 
	// 
	// 만약 const가 일반 변수처럼 포인터 값을 고정시킨다면, 
	// ptr_a는 다른 변수의 주소를 저장할 수 없어야 한다. 
	// 
	// 그러나 위 출력 결과를 보면, ptr_a는 const의 사용과는 무관하게 
	// 변수 b의 주소를 저장하고, 그 값을 간접 참조하여 출력하고 있다. 
	// 
	// 그렇다면 포인터에 사용된 const의 의미는 무엇일까?
	// ptr_a가 가리키는 변수 a는 ptr_a를 간접 참조하여 바꿀 수 없다는 의미이다. !!!!!
	// 
	// *ptr_a = 20; 과 같이 포인터 ptr_a를 간접 참조하여 a 값을 바꾸고자 한다면, 
	// error C2166: l-value가 const 개체를 지정합니다와 같은 에러가 발생한다. 	 
	// <= Error C2166 l-value specifies const object	
	// 
	// 하지만, 변수 a를 직접 참조하여 *ptr_a의 값을 바꿀 수는 있다. 
	// 
	//$ 포인터에 const를 사용하는 이유?
	// 변수 a는 어디까지나 포인터를 통해서만 바꿀 수 없으며, !!!!!
	// 변수 a 자체를 사용하면 얼마든지 바꿀 수 있다.        !!!!!
	// 
	// 그러면 왜 포인터에 const를 사용할까?
	// 포인터에 const를 사용하는 대표적인 예는, 문자열 상수를 인수로 받는 함수이다. 
	// 문자열 상수는 값이 바뀌면 안 되는 저장 공간이므로, 
	// 함수의 매개변수를 통해서 값을 바꿀 수 없도록 매개변수로 선언된 포인터에 const를 사용한다.
	// 문자열과 포인터의 관계는 12장에서 다룬다. 
	// 
	//$ 키워드
	// 포인터는 메모리를 사용하는 또 다른 방법이다. 
	// 주소 연산자 &로 변수가 할당된 메모리의 위치를 확인한다. 
	// 포인터로 가리키는 변수를 사용할 때, 간접 참조 연산자 *를 사용한다. 
	// 
	//$ 정리 
	// 주소 연산자: 
	//	   int a;
	//     &a;
	//      변수 앞에 붙여서 사용하며, 변수가 할당된 메모리의 시작 주솟값을 구한다. 
	// 포인터: 
	//	   char *ptr_c;
	//     int *ptr_i;
	//     double *ptr_d;
	//		시작 주솟값을 저장하는 변수이며, 가리키는 자료형을 표시하여 선언한다. 
	// 간접 참조 연산자: 
	//	   *ptr_i = 10;
	//      포인터에 사용하며, 포인터가 가리키는 변수를 사용한다. 
	// 
	// 포인터 선언할 때 사용하는 *와, 간접 참조 연산자 *는 모양은 같지만 완전히 다른 역할을 한다.
	// C언어를 만든 사람이 같은 기호 *를 사용했을 뿐이다. 

	return 0;
}