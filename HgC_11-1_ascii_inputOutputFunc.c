#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/* 11 - 1. 아스키 코드 값과 문자 입출력 함수
   문서를 편집하고 복사하는 프로그램은 문자열 데이터를 처리한다. 
   문자열은 문자를 기본으로 만들어지므로, 
   문자열을 자유롭게 다루려면 문자에 대한 이해가 필수적이다. 
   
   문자의 표현과 연산, 입출력 등에 대해서 살펴 보자. 
 
   프로그램에서 문자을 사용할 때는 항상 양쪽에 작은따옴표를 붙인다. 
   컴파일러는 a를 변수명으로 해석하는 반면, 
   'a'는 문자 상수로 해석한다. 
  
   그러나 이런 문자 표현법은 컴파일 후에는 
   약속된 정수 값인 아스키 코드 값으로 바뀌기 때문에 더 이상 의미가 없다. 
 
   예를 들어 문자 상수 'a'는 정수 값 97로 바뀐다. 
   결국 문자는 메모리에 저장되는 방식이 정수와 같다. 
   따라서 int 형 변수에 저장하고 정수처럼 연산할 수 있다. 
  
   즉, 문자 'a'를 %d로 출력하면 97을 출력하고, 
   반대로 정수 97을 %c로 출력하면 아스키 코드 값이 97인 문자를 출력한다. !!!!!
 
   결론적으로 문자 상수 'a'와 정수 97은 같은 데이터이며, 
   변환 문자열의 종류에 따라 출력 형태가 결정된다. 
  
      상수 표현           문자 'a'               정수 97
                             \                   /
             아스키 코드 값을  \                 / 2진수로 변환
                 2진수로 변환   \               /
                                v             v
      저장 형태         00000000 00000000 00000000 01100001
                                /             \
                      %d로 출력 /               \ %c로 출력
                               v                v
      출력 형태            10 진수 97       아스키 코드 값이 
                                           97인 문자 'a'
*/
/*
  $ 아스키 코드
   아스키 코드는 128개의 문자를 0~127의 숫자 중에 
   각각 어떤 값으로 표현할지 정의한 것이다.  
   
        종류             문자 상수      아스키 코드 값     출력할 때
    숫자 문자(10개)    '0' ~ '9'        48 ~ 57          문자 출력
    대문자 (26개)      'A' ~ 'Z'        65 ~ 90          문자 출력
    소문자 (26개)      'a' ~ 'z'        97 ~ 122         문자 출력
    제어 문자 (33개)   '\0', '\t',      0, 9,            문자 출력
                      '\n', '\r'       10, 13
   
   표를 통해 알 수 있는 아스키 코드 값의 특징은 다음과 같다. 
   - 알파벳과 숫자는 각각 연속된 아스키 코드 값을 갖는다. 
   - 소문자가 대문자보다 아스키 코드 값이 크다. 
   - 제어 문자는 백슬래시 \와 함께 표시하며 출력할 때 그 기능을 수행한다. 
*/
int main() {

	// 손코딩 11-1. 대문자를 소문자로 변경
    char lower, upper = 'G';          // char 형 변수 선언과 초기화

    if ((upper >= 'A') && (upper <= 'Z')) {   // 대문자 범위라면
        lower = upper + ('a' - 'A');          // 대/소문자의 차이를 더해 
                                              // 소문자로 변환
    }

    printf("대문자: %c %c", upper, '\n');      // \n을 %c로 출력하면 줄이 바뀐다.
    printf("소문자: %c", lower);

	return 0;
}
// 실행 결과:
// 대문자: G
// 소문자: g

/* 위 예제에서,  
 char lower, upper = 'G';은 문자을 저장하기 위해 char 형 변수를 선언하고 초기화한다.

 문자 상수는 4바이트의 크기를 갖지만 아스키 코드 값이 0 ~ 127의 범위에 있으므로, 
 2진수로 바꾸면 왼쪽 3바이트는 모두 0이 되고 오른쪽 1바이트만 의미를 갖는다. 

 따라서 문자는 1바이트 크기의 char 형 변수에 저장해 사용할 수 있다. 
 컴파일러는 문자에서 아스크 코드 값을 갖는 오른쪽 1바이트만 변수에 저장하고 
 남는 바이트는 버린다. 

     문자 'G'  00000000 00000000 00000000 01000111
               <------------------------> <------>
                  저장할 공간이 없으므로       |
                  버려짐                      | 저장
                                              v
                         char 형 변수 upper 01000111

 if ((upper >= 'A') && (upper <= 'Z'))은 변수 upper에 저장된 문자가 
                      대문자의 아스크 코드 값 범위에 속하는지 검사한다. 
                      upper에 저장된 문자 'G'의 아스키 코드 값은 71이고, 
                      대문자 A(65)와 Z(80) 사이의 값이므로 if 문의 조건식은 참이 된다. 
 
 결국 
     lower = upper + ('a' - 'A');에서 upper에 저장된 대문자를 소문자로 바꾸어 
                    변수 lower에 저장하는데, 이때 소문자에서 대문자를 뺀 차를 활용한다. 

 소문자는 대문자보다 아스키 코드 값이 크고 같은 문자끼리는 아스키 코드 값의 차가 일정하므로 
 'a' - 'A'의 값을 대문자 'G'에 더하면 소문자 'g'를 구할 수 있다. 

     lower = upper + ('a' - 'A');

        a     b     c  ...  g  ...  z
       (97)  (98)  (99)    (103)   (122)
        ^                   ^
    +32 |                   | +32
        A     B     C       G       Z
       (65)  (66)  (67)    (71)    (90)
        
$note
    아스키 코드에서 알파벳 대문자가 소문자보다 먼저 위치하는 점을 이용한 계산이다.

 제어 문자를 프로그램에서 상수로 쓸 때는 백슬래시 \와 제어 기능을 암시하는 문자를 함께 사용한다. 
 즉, 줄을 바꾸는 new line의 n을 따서 \n과 같이 표현한다. 

 제어 문자는 형태가 없으므로 %c로 출력하면 해당 제어 기능이 수행된다. 
 따라서 

     printf("대문자: %c %c", upper, '\n');는 
                                           upper에 저장된 문자를 출력한 후에 줄을 바꾼다. 

$note
    제어 문자는 데이터 통신에 쓰이거나 화면의 출력 위치를 조정한다. 2장 제어 문자의 종류 참고
*/