#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// 12-1. 문자열과 포인터
// 문자열은 포인터와 관계가 깊어서 잘못 사용하면 에러를 찾기 힘들다. 
// 따라서 문자열을 자신 있게 다루려면, 문자열의 구현 방법을 정확히 이해해야 한다. 
// 
// 문자열의 정체를 파헤쳐 보고, 포인터로 문자열을 다루는 방법을 살펴 본다.

int main() {

	// printf("%s", "apple");은 apple이 출력된다.
	// 
	// "apple"을 각 문자 'a', 'p' 등을 가진 배열이라고 가정해 보자. 
	// 이것이 배열이라면 당연히 배열명을 사용할 것이고, 
	// 실제로는 배열의 시작 위치를 가지고 출력하게 될 것이다. 
	// 
	// 배열이 아닌 문자열을 직접 출력하는 경우도 마찬가지이다. 
	// 컴파일 과정에서 문자열은 첫 번째 문자의 주소로 둔갑하고,
	// 그 이후는 배열을 출력하는 것과 같은 과정을 거친다.
	// 
	// <= 문자열은 배열의 구조를 가지며, 첫 번째 문자의 주소로 쓰인다.

	printf("%s,\t%p\n", "apple", "apple");	// apple,  00007FF718E19C24

	//              "apple"은 'a'가 저장된 주솟값 
	//                         |
	// "apple"이 배열이라면 ---> | a | p | p | l | e | \0 |
	//                         배열의 주소이자, 
	//                         첫 번째 문자의 주소

	printf("\t%p %p\n", "apple", &"apple");	// 00007FF718E19C24 00007FF718E19C24
	puts("");

	//$ 문자열 상수 구현 방법
	// 문자열의 크기는 일정하지 않다. 
	// 따라서, 컴파일러는 문자열 상수를 독특한 방법으로 처리한다. 
	// 컴파일 과정에서 문자열을 char 배열 형태로 따로 보관하고, 
	// 문자열 상수가 있던 곳에는 배열의 위치 값을 사용한다. 
	// 
	// 예를 들어 문자열 "apple"은 문자 'a'가 저장된 메모리의 주솟값으로 바뀐다. 
	{
		// 손코딩 12-1. 문자열 상수가 주소란 증거
		printf("apple이 저장된 시작 주솟값: %p\n", "apple");	  // 00007FF718E19C24
		printf("     두 번째 문자의 주솟값: %p\n", "apple" + 1); // 00007FF718E19C25
		printf("             첫 번째 문자: %c\n", *"apple");    // a, 간접 참조 연산
		printf("             두 번째 문자: %c\n", *("apple" + 1));// p, 포인터 연산식
		printf("배열로 표현한 세 번째 문자: %c\n", "apple"[2]);   // p, 배열 표현식 
	}


	return 0;
}

// printf("%p\n", "apple"); 은 문자열이 저장된 곳의 위치 값을 출력한다. 
// 문자열 "apple"은 배열 형태로 따로 저장되고, printf() 함수의 인수로 
// 그 첫 번째 문자 'a'의 주소가 사용된다. 
// 
// printf() 함수에서 %p로 출력하면, 그 값을 16진수로 확인할 수 있다. 
// p는 주로 포인터를 출력할 때, 사용하는 변환 문자이며, 
// 포인터 값을 16진수 대문자로 출력한다. 
// 
// printf("주솟값: %p\n", "apple");
//                        ------
//                  문자열은 따로 배열에 저장
//                                       
//         문자열이 저장된 시작 위치 값 --> 24  25  26  27  28  29
//                                      | a | p | p | l | e | \0 |   
//  첫 번째 문자의 주소 전달  _____________
//                        |
// printf("주솟값: %p\n", 24);
// 
// 결국 문자열은 컴파일 과정에서 char 변수의 주소로 바뀌므로, 
// 직접 포인터 연산을 수행할 수 있다.
// 
// printf("%p\n", "apple" + 1);
// 이렇게 정수를 더하면, 다음 문자의 주소를 구할 수 있고, 
// 
// printf("%c\n", *"apple");
// 이렇게 간접 참조 연산을 수행하면, 첫 번째 문자가 된다. 
// 
// printf("%c\n", "apple"[2]); 
// 이렇게 배열명처럼 사용하는 것도 가능하다. 
// 
// 단, 명심해야 할 것이 있다. 
//$ 주의!
// 주소로 접근해서 문자열을 바꿔서는 안 된다. 
// *"apple' = 't'; 와 같이 첫 번째 문자가 저장된 공간에 
// 다른 문자를 대입하여 그 값을 바꾸려는 시도는 위험하다. 
// 
// 연산 자체는 문제가 없으므로 정상적으로 컴파일되지만, 
// 실행할 때, 운영체제에 의해서 강제 종료될 가능성이 있다. 
// 
// 운영체제는 문자열 상수를 읽기 전용 메모리 영역에 저장한다. 
// 따라서 그 값을 바꾸는 명령의 실행을 제한한다. 
// <= 운영체제에 따라 다를 수 있으나, 호환성을 고려한다면 시도하지 마라.
// 
// 문자열을 주소로 바꾸면, 포인터 연산을 통해서 
// 문자열의 시작 위치부터 길이 제한 없이 사용할 수 있다. 
// 
// 이 경우 문자열의 끝을 알아야 하므로, 문자열의 끝을 표시하기 위해서 
// 널 문자 null character를 사용한다. 
// <= 컴파일러는 문자열 상수를 저장할 때, 마지막에 항상 널 문자를 붙여 준다.