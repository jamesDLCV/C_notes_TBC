#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// 10-2. 배열을 처리하는 함수
// 배열의 데이터를 처리하는 함수는 
// 많은 양의 배열 데이터를 효과적으로 공유하는 방법이 필요하다.
// 
// 배열명을 인수로 받아서 배열을 처리하는 함수에 대해 살펴 본다.

void print_arr(int* ptr_a);

int main() {

	// 배열과 포인터에 대해 배웠지만, 
	// 배열명을 꼭 포인터에 넣는 방식으로 배열을 처리할 필요는 없었다. 
	// 
	// 하지만, 함수로 배열을 처리하려면 포인터가 필요하다. 
	// arr 배열에서 배열명 arr는 첫 번째 배열 요소의 주소이다. 
	// 
	// 이 주솟값을 함수의 인수로 주면, 함수는 이 값을 받아 주소 계산을 통해서 
	// 모든 배열 요소를 사용할 수 있다. 
	// 
	// 이때 배열명을 받을 함수의 매개 변수 자리에 포인터가 필요하다.           !!!!!
	// 
	// int arr[5] = { 10, 20, 30, 40, 50 };
	// 
	// 배열명 arr   ==  100    104    108    112    116
	// 첫 번째 배열      |  10  |  20  |  30  |  40  |  50  |
	// 요소의 주소        int 형 
	//                    변수
	// 
	// 배열 요소를 출력하는 print_arr() 함수를 만들었다면, 다음과 같이 호출할 수 있다.
	// 
	// print_arr(arr);
	// 
	// 배열의 모든 요소는 int 형이며 당연히 첫 번째 요소도 int 형이다. 
	// 
	// 배열명을 함수의 인수로 준다는 건 결국 int 형 변수의 주소를 전달하는 것이다. 
	// 따라서, 매개 변수로 받을 때는 int 형 변수의 주소를 저장할 포인터를 선언해야 한다.
	// 
	// void print_arr(int* ptr_a)                                      !!!!!


	//$ 배열의 값을 출력하는 함수
	// 배열의 값을 확인하기 위해서 수시로 출력을 해야 한다면, 
	// 그 기능을 함수로 만들어 호출하면 된다. 
	// 
	// 이때 모든 배열 요소를 함수의 인수로 줘야 할까?
	// 아니다. 첫 번째 배열 요소의 주소만 넣어 주면, 
	// 나머지 배열 요소는 포인터 연산으로 모두 사용할 수 있다. 
	// 
	// 따라서 함수를 호출할 때는, 배열명을 주고, 함수의 매개 변수로 포인터를 선언한다. 
	// 그리고 함수 안에서 포인터를 배열명처럼 사요한다. 
	// 
	// <= 배열을 처리하는 함수에 필요한 것은 배열의 주소이다. 
	// 
	// 배열명 자체가 주소이므로 그 주솟값을 함수의 인수로 주는 것이다. 
	// 예제를 통해 함수의 구체적인 사용법을 살펴 보자. 
	{
		// main() 함수의 내용
		int arr[5] = { 10, 20, 30, 40, 50 };

		print_arr(arr);					// 배열명을 주고 함수 호출 !!!!!

	}

	// print_arr(arr);	
	// <= 배열명 arr를 주고 함수를 호출한다. 
	// 
	// 배열명은 첫 번째 배열 요소의 주소이며, 첫 번째 요소는 int 형이므로, 
	// 결국 int 형 변수의 주소가 함수에 전달된다. 
	// 
	// 따라서 
	// void print_arr(int* ptr_a) {  } 
	// <= 함수의 매개 변수로 int 형을 가리키는 포인터 ptr_a를 선언한다. 
	// 
	// 함수가 호출되어 print_arr() 함수가 실행될 때의 상황은 다음과 같다. 
	// 
	// 배열명 arr   ==  100    104    108    112    116
	// 첫 번째 배열      |  10  |  20  |  30  |  40  |  50  |
	// 요소의 주소        int 형 
	//                    변수 
	// print_arr 
	// 함수 영역   
	// 포인터 ptr_a ==  100
	// 
	// print_arr() 함수에서 arr 배열에 관해 알고 있는 유일한 정보는, 
	// ptr_a에 받은 첫 번째 배열 요소의 주소 100번지뿐이다. 
	// 
	// 이미 배열의 크기를 알고 있다면, 그걸로 충분하다. 
	// ptr_a에 정수를 더하면 나머지 배열 요소의 주소를 구할 수 있고, 
	// 간접 참조 연산으로 가리키는 배열 요소의 값도 사용할 수 있다. 
	// 
	// 이때 배열 요소 표현식을 쓰면 마치 ptr_a도 배열명인 것처럼 사용할 수 있다.
	//
	//$ 정리
	//      정수 연산         ptr_a + 1      두 번째 배열 요소의 주소 104번지
	//    간접 참조 연산     *(ptr_a + 1)     두 번째 배열 요소
	//   배열 요소 표현식       ptr_a[1]		두 번째 배열 요소
	// 
	// <= i 값이 중가하면서 arr 배열의 모든 값을 출력한다.
	// 
	// 배열의 값을 출력할 때는 언제든지 배열명 arr를 인수로 주고, 
	// print_arr() 함수를 호출하면 된다. <= print_arr(arr);
	// 
	// 이때 print_arr()의 매개 변수로는 포인터 선언을 해야 한다.    !!!!!
	// 
	// 이 print_arr() 함수 예제는 동일한 배열의 데이터를 2개의 함수가 공유한다. 
	// print_arr() 함수는 주소를 매개 변수로 받아서, 
	// main() 함수에 있는 배열의 값을 출력한다. 
	// 
	// 이와 같은 처리 방식은 배열에 있는 대량의 데이터를 
	// 다른 함수로 복사하지 않고 접근하므로, 더 효율적이다. 
	// 
	// 다만, 주소만 알면 해당 위치의 값을 바꿀 수도 있으므로 
	// 의도치 않게 값을 변형하는 일이 없도록 주의해야 한다. 
	// 
	//$ 질문: print_arr() 함수에서 배열명 arr을 직접 사용할 수 없나요?
	// 직접 사용할 수 없다. 
	// 
	// 함수 안에 선언된 변수나 배열의 이름은 
	// 사용 범위가 중괄호 블록 {} 안으로 제한되므로, 함수 안에서만 사용할 수 있다. 
	// 
	// 따라서 print_arr() 함수에서는 main() 함수에 있는 배열명 arr를 
	// 직접 사용할 수는 없다. 
	// 
	// 이런 사용 영역 제한 때문에 서로 다른 함수에서 
	// 같은 이름의 변수나 배열을 독립적으로 사용할 수 있다.  
	// 
	// 각 함수 안에 사용한 변수나 배열의 이름은 사용 영역이 다르므로, 
	// 다른 함수에 있는 동일한 이름의 변수나 배열과 서로 충돌하지 않는다.  

	return 0;
}

void print_arr(int* ptr_a) {			// 매개 변수로 포인터 선언 !!!!!

	for (int i = 0; i < 5; ++i) {
		printf("%d ", ptr_a[i]);		// 포인터를 배열처럼 사용.
	}
	puts("");

	for (int i = 0; i < 5; ++i) {
		printf("%d ", *(ptr_a + i));	// ptr_a 자체의 값은 바꾸지 않음.
	}
	puts("");

	for (int i = 0; i < 5; ++i) {
		printf("%d ", *(ptr_a++));		// ptr_a 자체의 값을 바꾸고 있음.
	}
	puts("");

	for (int i = 0; i < 5; ++i) {
		printf("%d ", *(ptr_a++));		// 쓰레기 값 출력, 포인터 연산에 의해 
	}									// 주소가 선언된 배열의 범위를 벗어난다. 
	puts("");

	printf("%u", sizeof(ptr_a));		// x64에서 8, x86에서는 4
}

// *(ptr_a++) 와 같은 포인터 연산은 주의가 필요하다. 
// 위 함수 안에서와 같이 연속으로 사용하면, 쓰레기 값이 출력될 수 있다. 