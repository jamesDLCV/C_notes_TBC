#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>	// malloc(), free()

// 동적 할당 메모리는 배열처럼 사용할 수 있다. 

int main() {
	
	/* Dynamically Allocated Array */

	double* ptr = NULL;
	int n = 5;
	ptr = (double*)malloc(n * sizeof(double));

	if (ptr != NULL)	// if (!ptr)
	{
		for (int i = 0; i < n; ++i) {
			printf("%f ", ptr[i]);
			printf("\n");
		}
		printf("\n");

		for (int i = 0; i < n; ++i) {
			*(ptr + i) = (double)i;
		}

		for (int i = 0; i < n; ++i) {
			printf("%f ", ptr[i]);
			printf("\n");
		}
		printf("\n");
	}

	// free()를 하고 NULL 값을 넣어 주는 것이 좋은 습관이다.
	free(ptr);
	ptr = NULL;

	/*
		Comparision to VLA

		VLA
		- not supported by VS compilers.
		- automatic duration, cannot be resized
		- limited by stack size 
		  (when compiler places VLA in stack sement)
	*/
	
	return 0;
}

// int n = 5;
// (double*)malloc(n * sizeof(double));
// malloc() 함수에 들어가는 숫자로 expression을 넣을 수 있다. 
//	<= 몇 bytes를 요청할지 숫자를 넣어 줘야 한다. 
// n의 값은 런 타임으로 읽어 들여도 된다. 
//	인터넷에서, 파일에서 읽어 들여서 매번 변하는 메모리 크기를 요청할 수 있다. 
// 
// 실행할 때에야 배열의 크기를 알 수 있는 경우에 malloc() 함수를 쓸 수 있다.
// ptr[i] 이렇게 indexing 해서 배열처럼 사용할 수도 있고, 
// *(ptr + i) 이렇게 포인터 연산을 이용해서 배열처럼 사용할 수도 있다. 
// 
// 메모리를 할당 받아오기만 하고 초기화를 해 주지 않았기 때문에,
// 실행해 보면, 이상한 값이 출력된다. 쓰레기 값이 잔뜩 들어 있다. 
// 
//-6277438562204192487878988888393020692503707483087375482269988814848.000000
//-6277438562204192487878988888393020692503707483087375482269988814848.000000
//- 6277438562204192487878988888393020692503707483087375482269988814848.000000
//- 6277438562204192487878988888393020692503707483087375482269988814848.000000
//- 6277438562204192487878988888393020692503707483087375482269988814848.000000
// 
// *(ptr + i) = (double)i; <= i를 double로 해서 넣어 주면, 
// 
//0.000000
//1.000000
//2.000000
//3.000000
//4.000000
// 
// 이렇게 double 값이 제대로 출력이 된다. <= 초기화를 해 줬으므로. 
// 
// 동적 할당 메모리는 malloc() 함수를 사용해서 메모리를 받아왔을 때는,
// 0으로 초기화를 해 주지 않는다. <= 기억을 해 둬라!
// 
// 초기화를 해 주는 함수도 있으나 다른 강의에서 소개한다. 
// 
// 동적 할당 배열에서는 마치 길이가 변할 수 있는 배열처럼 사용할 수 있다. 
// 
// 위에서 n의 값이 바뀌면 할당 받은 메모리를 지우고, free() 해 버리고, 
// 다시 할당을 받으면 된다. 
// 다시 할당받아야 하는 게 번거롭다고 생각할 수도 있으나, 
// 배열의 길이를 아예 못 바꾸는 것과는 편의성 측면에서 천지 차이이다. 
// 
// 메모리 사용이 끝나면 다음과 같이 마무리를 해 주는 것이 좋다. 
// free(ptr);
// ptr = NULL;
// 
// VLA, variable length arrays, 가변 길이 배열과 비교를 해 보자.
// Visual studio compiler에서는 지원을 안 해 준다. GCC에서는 된다. 
// 대부분의 프로그래머들은 VLA보다는 동적 할당 메모리를 선호할 것이다. 
// VLA은 메모리는 한 번 받아오면 고정돼서 사이즈를 바꿀 수 없지만, 
// 동적 할당에서는 다른 사이즈의 메모리를 다시 받아올 수가 있다. 
// 
// VLA은 automatic duration을 갖는다.
//	<= 일반적인 변수처럼 stack에 올라가는 것이 일반적이다. 
// 동적 할당 메모리의 장점이나 단점은 Heap에 계속 있는 것이다. 
//  <= free()로 반납해 줄 때가지 계속 Heap에 존재한다. 
//  블록을 벗어나서 포인터의 주소를 잃어 버릴 수도 있지만,
//	힙에 항상 존재한다. 
// 
// VLA 같은 경우는 컴파일에 따라 다르지만, 
// stack segment에 저장될 경우, stack의 size에 제한된다. 
// stack size가 그렇게 크지가 않다. 
// Heap 같은 경우는 크기가 크다. Heap의 어디에 있는지 찾기가 힘들다. 
// 
// 여기까지 동적 할당 메모리의 기본적인 측면으로 문법적 측면과 
// 사용 시 주의할 점을 언급했다. 
// 자료 구조, 알고리즘 공부할 때 도움이 되기 위해 주의점을 반복해서 언급했다. 
// 
// 메모리를 할당받고 반납하는 과정이 번거로울 수 있다. 
// 기초 때는 번거롭더라도 공부를 해 두는 것이 좋다. 
// 
// 나중에 C++, python을 공부하게 되면 이런 할당과 반납을 언어에서 처리해 준다.
// modern C++에서는 이러한 것을 편하게 처리하도록 바뀌었다. 
// 