#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//$ 배열명과 포인터의 차이
// 포인터가 배열명처럼 쓰이기는 하지만 서로 다른 점이 더 많다. 

int main() {

	// 차이점 1. 연산의 결과가 다르다. 
	// 배열명에서 사용하면 배열 전체의 크기를 구하고, 
	// 포인터를 사용하면, 포인터 하나의 크기를 구한다. 
	// 따라서, 배열명을 포인터에 저장하면, 
	// 포인터로 배열 전체의 크기를 확인하는 것은 불가능하다. 
	{
		int arr[3];
		int* ptr_a = arr;

		int s1 = sizeof(arr);	  // 12바이트, 배열 전체 크기. x64에서도 12바이트
		int s2 = sizeof(ptr_a);	  // 4바이트, 포인터 하나의 크기. x64에서는 8바이트
		int s3 = sizeof(arr[0]);

		printf("배열의 크기     \tsizeof(arr) = %d\n", s1);
		printf("포인터의 크기   \tsizeof(ptr_a) = %d\n", s2);
		printf("배열 한 개의 크기\tsizeof(ptr_a) = %d\n", s3);
	}

	// 차이점 2. 변수와 상수의 차이가 있다. 
	// 포인터는 그 값을 바꿀 수 있지만, 배열명은 상수이므로 값을 바꿀 수 없다. 
	// 
	// 포인터 ptr_a에 1을 더하여 다시 ptr_a에 저장할 수 있다.
	// 배열명 arr에 1을 더하는 것은 가능하지만, 그 값을 다시 저장하는 것은 불가능하다. 
	// 
	//		포인터는 값을 바꿀 수 있음  vs.  배열명은 값을 바꿀 수 없음
	//      ptr_a = ptr_a + 1;            arr = arr + 1;  <= 안 된다!!!
	//      ptr_a++;					  arr++;		  <= 안 된다!!!
	// 
	// 그 외에도 배열명이 가지는 자료형의 의미가 있으나 
	// 다차원 배열과 응용 포인터에서 별도로 설명한다. 
	printf("\n");
	// 
	// 포인터가 지닌 변수로서의 특징을 활용하는 예를 살펴 보자.
	{
		int arr[3] = { 10, 20 , 30 };
		int* ptr_a = arr;
		int size = sizeof(arr) / sizeof(arr[0]);

		printf("배열의 값: ");
		for (int i = 0; i < size; ++i) {
			printf("%d ", *ptr_a);		  // ptr_a가 가리키는 배열 요수 출력
		}                                 // 다음 배열 요소를 가리키게 할 수단이 없다
		printf("\n");

		printf("배열의 값: ");
		for (int i = 0; i < size; ++i) {
			printf("%d ", *ptr_a);		  // ptr_a가 가리키는 배열 요수 출력
			ptr_a++;					  // 다음 배열 요소를 가리키도록
		}								  // ptr_a 값을 증가시킨다. 
		printf("\n");
	}
	// int arr[3] = { 10, 20 , 30 };
	// int* ptr_a = arr;
	// 
	// 배열명 arr == 100	   104    108
	//              |  10  |  20  |  30  |
	// 포인터 ptr_a  100
	//
	// 이 상태에서 포인터 ptr_a로 첫 번째 배열 요소를 출력하는 방법은 여러 가지가 있다.
	// 
	// 방법 1. ptr_a를 배열명처럼 사용하여 첫 번째 배열 요소를 출력하는 방법
	// printf("%d", ptr_a[0]);
	// 
	// 방법 2. ptr_a[0]을 그대로 포인터 연산식으로 바꾸는 방법
	// printf("%d", *(ptr_a + 0);
	// 
	// 방법 3. *(ptr_a + 0)에서 의미 없는 0과 괄호를 제거한 표현 방법
	// printf("%d", *ptr_a);
	// 
	// 표현 방법은 다르지만 모두 첫 번째 배열 요소를 출력한다. 
	// 
	// 이중 마지막 방법의 경우, ptr_a는 첫 번째 배열 요소를 가리키므로,
	// *ptr_a의 연산식으로 첫 번째 배열 요소의 값을 출력한다. 
	// 
	// *ptr_a = *ptr_a + 1; 또는
	// *ptr_a++;			를 통해 두 번째 배열 요소의 값을 출력할 수 있다. 	
	// 
	// 이런 방식이 가능한 이유는, 
	// 포인터 ptr_a가 변수이므로, 그 값을 바꿀 수 있기 때문이다. 
	// 
	// 다음처럼 포인터로 배열 요소를 차례로 출력할 때, 
	// 증가 연산자와 간접 참조 연산자를 함께 사용하는 방법도 있다. 
	{
		int arr[3] = { 50, 60 , 70 };
		int* ptr_a = arr;
		int size = sizeof(arr) / sizeof(arr[0]);

		printf("배열의 값: ");
		for (int i = 0; i < size; ++i) {
			printf("%d ", *(ptr_a++));		// 이런 식으로 사용할 수도 있다.  
		}
		printf("\n\n");
	}
	// *(ptr_a++)에서 괄호를 안 써 줘도,
	// 연산자 우선 순위에 따라 ptr_a++가 먼저 수행되므로 ptr_a의 값은 증가한다. 
	// <= 후위형이므로 증가는 ;을 만난 후에야 수행이 되므로,
	//    다음 연산인 간접 참조 연산을 수행할 때는 증가되기 이전의 값을 사용한다.
	// 
	// 컴파일러는 ptr_a가 증가되기 이전 값을 임시 공간에 저장해 두었다가, 
	// 간접 참조 연산에 사용하거나 또는 연산자 우선 순위를 바꾸어서,
	// ptr_a++보다 *ptr_a의 연산을 먼저 수행하도록 컴파일한다. 
	// 
	// 컴파일러가 어떤 방식을 사용하든 결국 ptr_a가 가리키던 배열 요소의 값이 
	// 먼저 출력되고, ptr_a가 다음 배열 요소를 가리키는 것과 결과는 같다. 
	// 
	// 
	// 포인터로 배열의 데이터를 처리할 때 주의할 점이 있다. 
	// 
	// 주의 1. 포인터의 값이 변할 수 있으므로 유효한 값인지 확인하는 습관이 필요하다.
	// 
	// 예를 들어, 위 예제에서 반복문을 모두 수행한 후에, ptr_a의 값은 112번지가 되며,
	// (ptr_a은 100번지라고 가정하므로, 3회 반복 후의 (ptr_a + 3)은 112번지가 된다)
	// 이 값은 배열에 할당된 영역의 주소가 아니므로, 
	// 간접 참조 연산을 통해서 그 공간이나 저장된 값을 사용해서는 안 된다. 
	// 
	// 만약 ptr_a로 다시 배열의 처음부터 데이터를 처리해야 한다면, 
	// 배열명으로 다시 초기화를 한다. 
	// 
	// 배열명은 주소 상수이며, 그 값이 바뀌지 않으므로 
	// 언제든지 배열의 시작 위치를 찾아갈 때 사용할 수 있다. 
	// 
	// 같은 방식으로 입력을 받을 때는 간접 참조 연산 없이 포인터만 사용한다. 
	// scanf() 함수는 입력할 배열 요소의 주소가 필요하므로 
	// 그 값을 갖고 있는 포인터를 그대로 사용하면 된다. 
	{
		// 키도드로 배열의 요소를 입력하기
		int arr[3];
		int* ptr_a = arr;

		printf("숫자 3개를 입력하세요 (배열 요소 입력): ");
		for (int i = 0; i < 3; ++i) {
			scanf_s("%d", ptr_a);		// ptr_a가 가리키는 배열 요소에 입력, 
										// 간접 참조 연산 없음
			++ptr_a;					// 다음 배열 요소를 가리키도록 ptr_a 증가
		}
		printf("\n");

		for (int i = 0; i < 3; ++i) {
			printf("%d ", *ptr_a);   // <= 제대로 작동하지 않음. 왜???????
			ptr_a++;                 // 위 입력에서 ptr_a는 이미 ptr_a + 2의 값임
		}
		printf("\n");

		ptr_a = arr;					// 초기화를 해 줘야 한다. 
		for (int i = 0; i < 3; ++i) {
			printf("%d ", *ptr_a);      // <= 제대로 작동함. 왜???????
			ptr_a++;                    // ptr_a = arr; 다시 초기화를 해 줌.
		}
		printf("\n");

		ptr_a = arr;
		for (int i = 0; i < 3; ++i) {
			printf("%d ", ptr_a[i]);    // <= 제대로 작동함 왜???????			
		}                               // ptr_a = arr; 다시 초기화를 해 줌.
		printf("\n");

		for (int i = 0; i < 3; ++i) {
			printf("%d ", *(arr + i));	// <= 제대로 작동함. 포인터 연산이 안 되므로
		}                               //    ptr_a++;의 영향이 없음.
		printf("\n");

		for (int i = 0; i < 3; ++i) {
			printf("%d ", arr[i]);	    // <= 제대로 작동함.	
		}
		printf("\n\n");
	}

	// 주의 2. 포인터에 증가 연산자와 간접 참조 연산자를 함께 사용할 때, 
	//        전위 표현을 사용하면 안 된다. 
	// 전위 표현을 사용하면 전혀 다른 결과가 출력된다. 
	// *(++ptr_a)는 ptr_a의 값이 먼저 증가된 후에, 
	// 증가된 ptr_a가 가리키는 배열 요소를 간접 참조하므로, 
	// 두 번째 배열 요소부터 출력된다. 
	//
	// 따라서 마지막에 출력되는 값은 배열의 값이 아닌 쓰레기 값이 출력된다. 
	// 
	// 또한 전위형이나 후위형 모두 괄호를 생략해도 결과는 같다. 
	// 간접 참조 연산자와 증가 연산자는 모두 단항 연산자로 우선 순위가 같다. 
	// *(++ptr_a)의 경우 오른쪽에서 왼쪽으로 항상 증가 연산자가 먼저 수행된다. 
	// *ptr_a++ 도 오른쪽에서 왼쪽으로 연산자가 수행된다. 
	// 
	//$ 괄호를 간접 참조 연산자에 먼저 사용하면 어떨까?
	// ++(*ptr_a);
	// 이 경우 ptr_a의 값 자체는 바뀌지 않으며, 
	// 첫 번째 배열 요소를 가리키는 상태로 고정된다. 
	// 그리고 ptr_a가 가리키는 배열 요소의 값이 증가하면서 차례로 출력된다. 
	// 전위형은 ptr_a가 가리키는 배열 요소의 값을 증가시킨 후에 출력하며,
	// 후위형은 먼저 출력하고 나중에 값을 증가시킨다. 
	{
		// (*ptr_a)++
		puts("(*ptr_a)++");
		int arr[3] = { 100, 200 , 300 };
		int* ptr_a = arr;
		int size = sizeof(arr) / sizeof(arr[0]);

		printf("배열의 값: ");
		for (int i = 0; i < size; ++i) {
			printf("%d ", (*ptr_a)++);		// 100, 101, 102  
		}
		printf("\n\n");
	}

	{
		// ++(*ptr_a)
		puts("++(*ptr_a)");
		int arr[3] = { 100, 200 , 300 };
		int* ptr_a = arr;
		int size = sizeof(arr) / sizeof(arr[0]);

		printf("배열의 값: ");
		for (int i = 0; i < size; ++i) {
			printf("%d ", ++(*ptr_a));		// 101 102 103
		}
		printf("\n\n");
	}

	return 0;
}