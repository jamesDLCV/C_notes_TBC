#include <stdio.h>
// C언어로 만든 프로그램이 실행될 때, 메모리를 어떻게 사용하는지
// 어떤 구조로 사용을 하는지, 흔히 메모리 레이아웃이라고 불리는 내용을 훑어 보겠다. 
// 
// 프로그램을 실행시키려면, 프로그램 자체가 메모리에 올라가야 한다. 
// 한 번 작성된 프로그램은 내용이 변경되면 안 된다. 
// 그러므로 프로그램 코드는 TEXT Segment라는 부분에 Read Only 읽을 수 있는 형태로만
// 저장이 된다. 만약 여기에 있는 코드를 변경시키려고 하면, 운영체제가 막는다. 
// eg) const char* message = "Banana"; <= "Banana"는 Text Segment에 저장된다. 
// 바뀌면 안 되는 내용이기 때문이다. 강제로 값을 바꾸려고 하면 운영체제가
// Run-Time error를 발생시키면서 막아 버린다. // 
// function pointer를 공부하면서 좀 더 자세하게 살펴볼 것이다. 
// 
// function pointer는 함수 자체의 주소이다. // 
// 함수 자체도 메모리에 저장이 돼 있다. 
// 그러므로, function도 주소를 가지고 올 수 있다. 
// 
// 프로그램이 한 번 메모리에 올라오면, 끝날 때까지 계속 있어야 한다?  
// 어떤 변수는 프로그램 전체에서 사용될 수가 있다. 
// 우리가 만든 대부분의 변수는 main() 함수 안에서만 사용할 수 있는 지역변수였다. 
// 전역변수, scope, duration도 앞으로 다룰 것이다. 
// 
// 전역변수는 DATA Segment, BSS(Block Started by Symbol) Segement에 저장이 된다. 
// 프로그램 코드와 마찬가지로 프로그램이 끝날 때까지 계속 메모리에 남아 있다. 
//      초기화되지 않은 전역/정적 변수들 <= BSS
//      초기화된 전역/정적 변수들 <= DATA Segment
// 
// 운영체제나 컴파일러는 효율성을 엄청 중요하게 생각하는 사람들이 만들었다. 
// 운영체제는 아주 많은 프로그램들을 동시에 관리해야 한다. 
// 어떤 프로그램이 혼자 큰 메모리를 쥐고 있다면, 다른 프로그램들이 사용할 수 없다. 
// 효율성이 떨어진다. 
// 물론 메모리를 계속 사용해야만 하는 경우라면 계속 쥐고 있어야 할 것이지만,
// 사용하지 않는 시간이 더 길다면, 그 메모리를 다른 프로그램들이 사용할 수 있도록 
// 풀어놨다가 필요할 때만 쓰는 것이 좋다.
// 필요할 때 돌려주세~. 일단은 다른 프로그램이 쓸 수 있도록 
// 운영체제에서 관리하라. <= 이런 식으로 효율성을 더 높일 수가 있다. 
// 
// 초보 프로그래머에게 편한 것은 메모리 모든 것을 전역변수로 넣고 사용하는 것일 것이다.
//  
// 하지만, 실력이 늘면서 메모리를 항상 갖고 있어야 하는 것에 대해 부담감을 갖게 된다. 
// 운영체제나 컴파일러 입장에서도 이렇게 메모리를 비효율적으로 사용하는 것은 안 된다. 
// 그래서 local variable 지역변수를 사용한다. {} 안에서만 사용된다. 
// 메모리도 Stack이라는 다른 영역의 메모리를 사용한다. 
// { } 블럭을 실행할 때만 변수가 메모리에 들어간다. 
// 그 외의 경우는 메모리를 차지하지 않는다. 엄밀히 말하면, 그 메모리를 다른 프로그램이
// 사용할 수 있도록 운영체제에게 관린 권한을 넘겨주는 것이다. 
// 이 개념은 동적메모리와 만나게 된다. 
// 
// 스택 메모리 공간은 필요할 때는 늘어났다가 불필요할 때는 줄어든다. 
// 보다 효율적으로 메모리를 사용할 수 있다는 장점이 있다. 
// 
// main() 함수에 있는 변수는 결과적으로 프로그램 시작과 끝까지 계속 메모리에 
// 머물러 있는 것처럼 사용이 된다. 
// 
// 보다 효율적인 구조는 함수 같은 작은 영역을 만들고, 그 영역 안에 변수의 메모리를 
// 사용하면, 그 함수가 호출돼서 실행이 될 때만, 그 메모리를 차지하게 된다. 
// 
// main() 함수의 변수들은 스택 메모리에 쌓여 있을 것이고, 
// 함수의 변수는 스택에 있다가 없다가 한다. 즉 함수가 호출이 되면, 스택에 들어와서
// 메모리를 사용하다가 호출이 끝나면 다시 반환이 되는 형태로 사용이 된다. 
// 
// 스택 메모리가 늘었다 줄었다 하는 것은 원칙적으로 운영체제가 하는 것이 맞다. 
// 하지만 변수의 사이즈는 컴파일할 때 결정이 나 있다. 그러므로 스택에 들락거리는 것은
// 아주 효율적으로 작업을 할 수 있다. 
// 스택에서 메모리 공간이 열렸다 해제됐다 하는 것은, 아주 빠르게 작동한다. 
// 스택에 선언된 지역변수들은 속도가 빠르다. 
// 
// 스택이라는 단어의 뜻이 쌓는다는 의미이다. 
// 힙보다 주소가 높은 방향이다. 힙은 낮은 방향의 주소이다. 
// 
// 동적할당 메모리를 능숙하게 사용할 수 있다면, 
// 자료구조, 알고리즘도 무리 없이 공부할 수 있다.  
// C언어를 통한 컴퓨터 구조 공부가 끝나간다고 말할 수 있다. 
// 
// 메모리 사이즈가 크더라도 배열 같은 경우는, 사이즈가 미리 정해져 있었다. 
// 컴파일할 때 메모리를 얼마나 사용할지 미리 알 수 있는 구조였다. 
// 하지만, 실무에서 어떤 프로그램을 만들 때, 데이터를 얼마나 사용할지 
// 얼마나 큰 데이터를 사용할지 미리 알 수가 없다. 
// eg) 내가 만든 게임의 동시 접속자가 천 명이 될지, 만 명이 될지 알 수는 없다. 
// 
// 사용자가 scanf()를 통해서 메모리를 이만큼 잡아야 한다고 결정하는 경우, 
// 파일로부터 무엇을 읽어들이는 경우 등등, 
// 
// 앞으로 궁극적으로 만들게 될 프로그램은 대부분의 경우, 
// 메모리의 크기를 미리 알 수가 없다. 
// <= 이러한 개념을 받아들이기 시작하면 프로그래밍 실력이 급격히 좋아지기 시작한다. 
// 
// 이러한 경우, 컴파일할 때 미리 메모리의 사이즈를 알 수가 없기 때문에, 
// 힙Heap이라는 공간을 사용한다. // 
// 스택도 늘었다 줄었다 하지만 얼마나 사용할지를 컴파일할 때 이미 알고 있다. 
// 힙은 사이즈를 모른다. 자유 공간Free을 자유롭게 사용해야 한다. 
// 
// 운영체제 입장에서 어떤 프로그램이 어떤 메모리를 얼마나 사용할지 알 수 없으므로
// 할당되는 메모리조차 그때 그때 다르다. 
// 
// 스택은 내려오고, 힙은 올라가면, 가운데서 충돌이 날까? 
// 운영체제 기술에서는, 가상 주소 공간을 사용해서, 충돌이 안 나도록 관리를 해준다.
// 그렇다면 단점은 무엇일까?
// 가상 주소를 배정할 때 운영체제를 거쳐서 어디에 배정할지를 결정하므로
// 시간이 걸린다. 좀 느리다. 
// 
// 동적할당 메모리를 사용할 때는 메모리를 할당받거나 
// 다 쓴 메모리를 반납하는 과정이 필요하므로 느리다. 
// 
// 힙 메모리를 관리해야 한다는 개념이 조금 부담스러울 수 있다. 
// 메모리를 받아와서 다 썼으면 메모리를 반납을 해야 하기 때문이다. 
// 
// 스택에 올라가는 메모리는 영역이, 어떤 블럭 안에서 사용된다는 것이, 
// 프로그래밍할 때 미리 결정이 돼 있다. 
// 
// 힙에 올라오는 동적할당 메모리 같은 경우는, 메모리를 주세요 하고 받아 놓고
// 아예 쓰지 않을 수도 있고, 다 썼는데도 반납을 하지 않을 수도 있다. 
// 이것은 프로그래머에게 자유를 주기 위해서 꼭 필요한 내용이다. 
// 
// 이 문제를 해결하기 위해서, 다 썼으면, 프로그래머가 다 썼어요 라고 
// 꼬박 꼬박 반납을 해야 한다.   eg) free(arr);
// 
// C언어의 동적할당에서 많이 실수하는 부분이다.  
// 나중에 자료구조 공부를 할 때도 Run-Time Error의 원인이 된다. 
// 반드시 반납을 하는 습관을 들여라. 
// 
// 다른 언어들에서는 이런 메모리 관리는 자동으로 해 준다. 
// 따라서 실무에서 그렇게 고생을 하면서 프로그래밍을 할 일은 없다. 
// 다만 컴퓨터가 이렇게 작동하는구나라는 것을 머리에 심어 놓기 위해서 다루는 것이다. 
// 
// 구체적인 내용은 다음 강의에서 다룬다. 
//  
// C언어로 만든 프로그램이 메모리를 어떻게 기능적으로 나눠서 사용하는지 
// 메로리 레이아웃을 통해서 살펴봤다. 
// 
// 메모리 레이아웃: 
//  명령줄 인수와 환경 변수들 - 스택Stack - 자유 공간Free - 힙Heap 
//      - 초기화되지 않은 전역/정적 변수들 - 초기화된 지역/정적 변수들 - 프로그램 코드
//  
//

void func() {
    int i = 123;
    printf("%lld\n", (long long)&i);
}

int main() {
    const char* message = "Banana";
    printf("Apple and %s", message);
    printf("\n");

    void (*f_ptr)() = func; // address of a function

    printf("%lld\n", (long long)&message);
    printf("%lld\n", (long long)&f_ptr);
    printf("%lld\n", (long long)message);
    printf("%lld\n", (long long)f_ptr);
    printf("%lld\n", (long long)main);

    func();

    return 0;
}

//Apple and Banana
//9435756
//9435744
//5602104
//5574911
//5575376
//9435516