#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

// 메모리 동적 할당
// Dynamic Storage Allocation
// 
// '동적 저장 공간 할당'이라고 번역할 수도 있다.  
// 
// 동적이라는 단어의 의미는 컴파일 타임이 아니고,
// run time에 결정이 된다는 것이다.  
//	<= 지금까지 공부한 storage classes와 가장 큰 차이점이다. 
// 
// 동적 할당 메모리 (주의: 포인터만 가지고 오고, 인식자가 없다)
// 인식자가 없으므로 저장 공간 분류가 지금까지 다뤘던 다섯 가지와 다르다.
// 가장 중요한 차이는 Heap 힙에 들어간다. 
// 
// 프로그래머가 필요할 때마다 운영체제에게 그때 그때 요청을 한다. 
// 다 쓰고 나면 반납을 해 줘야 한다. <= 수동으로 관리를 해 줘야 한다. 
// 프로그래밍을 한 번 해 놓으면 그 프로그램이 알아서 처리하는 구조이다. 
// 
// 한 번 할당을 받으면 heap에 계속 존재를 한다. 
// 
// automatic 같은 경우는, block 안에서 선언이 되고, 
// statck에 넣다 뺐다를 자동으로 결정해 줘서 자동 저장 공간 분류라고 했다. 
// 
// 그러나 힙에 동적 할당 메모리가 한 번 자리를 잡으면, 
// 두 가지 경우가 있다. 
// 1. 프로그래머가 이제 이 메모리를 다 썼으므로 반납하겠다고 하는 경우,
// 2. 프로그램이 종료할 때 운영체제가 강제로 회수하는 경우. 
// 
// 예전에는 운영체제가 강제로 회수할 때 오류가 났으나 
// 최근에는 컴파일러가 해결해 준다. 
// 
// Heap에 있는 동적 메모리는 꼬박 꼬박 반납을 하는 습관을 들여야 한다. 
// 자료 구조를 공부할 때 동적 메모리를 반납하지 않으면 
// 오류가 생길 수 있다. 
// 
// 언제 사용하는가?
// 필요한 메모리의 크기를 미리 알 수 없을 경우에 사용한다. 
// 컴파일 타임에 필요한 메모리가 얼마인지 알 수가 없고, 
// Run time이 돼 봐야 알 수 있는 경우에는 동적 할당 메모리를 사용한다. 
// 
// 두 가지 방법이 있다. 
// 1. stack에 들어갈 메모리를 크게 잡는다. 
// 2. 동적 할당 메모리를 사용한다. 
// 
// 스택 같은 경우는 자유 공간으로 밀고 내려오면 크기에 제한이 있다. 
// 힙은 운영체제가 자유 공간에 가상 주소 공간을 사용하여 컴퓨터의 메모리를
// 충분히 사용할 수 있도록 도와 준다. 
// 
// 스택 같은 경우 컴파일 옵션에서 스택의 크기를 좀 크게 잡겠다고 할 수 있으나,
// 그렇게까지 하는 경우는 많지 않다. 
// 대부분의 경우 힙에 들어가는 자유 공간 메모리를 이용하는 것이 일반적이다. 
//	<= 동적 할당으로 받아서 사용하는 것이 일반적이다. 
// 
// Run time에서 메모리 크기가 결정될 때는, 
// 동적 할당 메모리를 사용하는 것이 일반적이다. 

int main() {

	int n = 0;

	// n from files, internet, scanf, etc.

	char* arr = (char*)malloc(sizeof(char) * n);

	//..

	free(arr);

	return 0;
}

// 변수 n에 의해서 메모리 사이즈가 바뀌고 있다. 
// 비슷한 경우는 VLA를 생각할 수가 있다. 
// 
// 가변 길이 배열도 배열의 길이를 변수를 이용해서 결정할 수 있었다. 
// 그 차이에 대해서 좀 더 살펴 보자. 
// 
// 동적 할당 메모리를 받아올 때는 malloc 엠 얼록, 말럭을 사용한다. 
// memory allocation의 약자이다. 
// #include <stdlib.h> <= 여기에 있으므로 include해 준다. 
// 
// 메모리를 받아왔으면 반드시 반납을 해 줘야 한다. 
//	<= free(arr);
// 운영체제에게 지금까지 사용한 메모리를 반납하는 것이다. 
// 어딘가에는 반드시 free()가 있어야 한다. <= 주의 사항!!!!!!!!
// 
// 코드를 보면서 문법적인 측면을 살펴 보자. 
// 