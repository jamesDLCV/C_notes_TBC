#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <windows.h>	// SetConsoleOutputCP()

// 텍스트 파일을 바이너리처럼 읽어 보기
// 
// 텍스트 파일도 결국은 바이너리로 저장이 된다. 
// 파일 시스템을 전반적으로 깊게 이해할 수 있도록,
// 텍스트 파일을 바이너리처럼 읽어 보고 무슨 일이 벌어지는지 살펴 본다.

int main() {

	FILE* fp = fopen("test.txt", "rb");

	unsigned char ch;

	SetConsoleOutputCP(CP_UTF8);	// UTF-8 mode

	while (fread(&ch, sizeof(unsigned char), 1, fp) > 0) {
		// printf(%c\n", ch);		// <= text file과 동일하게 출력
		printf("%hhu %c\n", ch, ch);
	}

	fclose(fp);

	return 0;
}

// test.txt 파일을 다음의 내용으로 만들었다.
/*
	ABC
	DE
	123
	C언어
	       <= 공백, (빈칸을 넣고 저장하면 아스키 코드 13, 10이 출력된다)
				   (빈칸 없이 저장하면 아스키 코드 13, 10은 없다) 
		           
*/
// 텍스트 파일의 우하단을 보면 CRLF가 써 있다. Carriage Return, Line Feed
// CR의 아스키 코드는 10, LF의 아스키 코드는 13이다. 
// 
// FILE* fp = fopen("test.txt", "rb"); <= 바이너리로 열고 있다. 
// 
// SetConsoleOutputCP(CP_UTF8);	// UTF-8 mode 
//	<= 한글 출력을 잘 되도록 하기 위해서 code page를 설정해 줬다. 
// 
// unsigned char ch; <= 1byte
// 
// while (fread(&ch, sizeof(unsigned char), 1, fp) > 0) {
//     printf("%c", ch);
// }
//  <= 1byte씩 쭉쭉 읽어 들이고 있다. 
//     fread() 함수의 반환 값은 읽어 들인 데이터의 양이다. 
//     읽어 들인 양이 0이라면, EOF이니까 break돼서 while()문 밖으로 나간다.
//     0보다 큰 값이 반환되면 계속 읽어 들인다. 
// 
//     fread(&ch, ~)		<= ch를 바이너리로 읽어 들인 다음에 
//     printf("%c", ch);	<= printf() %c로 출력하고 있다. 
// 
// 실행을 시켜 보면, 
// 텍스트 파일을 텍스트로 읽어 들인 것과 동일한 결과가 출력된다. 
// 분명히 바이너리로 열어서 fread()로 1byte씩 읽어 들였으나,
// 텍스트로 문제 없이 출력되고 있다. 
// 
// printf("%c", ch);을 아래와 같이 바꾸고 실행시켜 보자. 
// printf("%hhu %c\n", ch, ch); 
//  <= 아스키 코드도 찍어 보자. 
// 
// 바이너리 파일에서는, 우리가 저장하라고 하는 데이터 
// fwrite() 함수를 이용해서 순수하게 저장하라고 하는 데이터만 저장이 됐는데, 
// 
// 65 A
// 66 B
// 67 C
// 13
// 10
//		<= 빈칸
// 68 D
// 69 E
// 13
// 10
//
// 49 1
// 50 2
// 51 3
// 13
// 10
//
// 67 C
// 236
// 150
// 184
// 236
// 150
// 180
// 13
// 10
//      <= 마지막에 빈칸이 하나 더 있다. 
//	<= 이렇게 13, 10 (윈도우즈에서는 이렇게 두 기호를 이용해서 저장된다) 
//     빈칸도 운영체제에서 이용하는 뭔가가 더 있을 것인데 보이지는 않고 있다. 
//	알파벳과 숫자는 잘 나왔는데, 한글 두 글자가 사라졌다. 
//  236 이후가 한글이 아닐까라는 추측을 할 수 있다. 
//  
// 처음 UNIX, LINUX가 개발될 때에는, 국제어에 대한 고민이 없었다. 
// 전세계의 언어를 모두 사용하려다 보니까 여러 가지 기술이 추가가 되었다. 
// 조금 복잡해지고 있다. 
// 영어 이외의 언어를 사용할 때는 별도의 방식을 사용한다. 
// 
// 알파벳이나 숫자를 표현할 때는 한 글자 1byte를 사용하고, 
// 한글을 사용할 때는 3bytes를 사용한다. 
// 
// 국제어를 사용할 대는 여러 개의 bytes를 조합해서 사용할 수도 있다. 
// 
// 바이너리 데이터를 저장할 때는 그냥 바이너리 데이터를 저장했다가 읽어 들이지만, 
// 텍스트 파일을 저장할 때는 뭔가 추가적인 요소가 좀 붙는데, 
// 이 요소는 운영체제에 따라서 다를 수 있다. 
// 
// 위 출력을 보면 줄바꿈을 할 때 세 칸씩 비우고 있다. 
// (CR, LF, 알 수 없는 빈칸 이렇게 세 칸)
// 
// 그렇지만, 우리가 메모장이나 노트 패드로 파일을 읽어 들일 때는, 
// 13, 10, 알 수 없는 빈칸 <= 이런 것 없이 줄바꿈으로 표현된다. 
// 이는 메모장이나 노트 패드 프로그램이 우리가 보기 편하도록 도와 주기 때문에,
// 이럴 사항을 몰라도 아무 문제가 없다. 
// 
// 출력 마지막에 빈칸이 하나 더 있다 (무엇인가 더 있다)
// 윈도우즈에서는 파일의 끝을 표시한다. 
// 리눅스에서는 마지막에 한 글자를 추가하지 않는다. 
// 
// 이렇게 파일의 끝을 표시하는 방식은 운영체제마다 다를 수 있다. 
// 
// 텍스트 파일을 바이너리 파일로 한 번 열어 봤고 
// 열어 봤을 때, 그 안에 무엇이 있는지 데이터 측면에서 byte 단위로 분석을 해 봤고,
// 관련된 개념도 살펴 봤다. 
// 
// 실무에서 파일 입출력을 사용하게 되면, 호기심을 갖고 뜯어 보면서 작업을 하면, 
// 보다 깊이 있게 이용할 수 있을 것이다. 