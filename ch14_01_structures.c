#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// Structures, 구조체가 필요한 이유
//
// 구조체가 필요한 이유?
// 환자 천 명, 변수 천 개 <= 이럴 수는 없다. 
// 배열을 사용한다?
// names[9][3]...... <= 이런 식으로 해도 프로그래머 입장에서는 상당히 번거롭다. 
// 또, 서로 다른 자료형의 데이터를 묶을 수가 있는가?
// 배열은 자료형이 같은 데이터 오브젝트들이 나열된 형태이다. 
// 
// 그래서 구조체를 사용하게 된다. <= 다른 자료형을 함께 묶을 수가 있다. !!!
// 자료형이 서로 다르지만 함께 사용하면 편리한 데이터 오브젝트들 끼리 모아 놓는다. 

#define MAX_NAME 30

/* Structures */
struct Patient	// Patient라는 태그를 갖는 구조체. 이름이라고 생각해도 된다. 
{
	char name[MAX_NAME];
	float height;
	float weight;
	int age;
};

int main() {	

	struct Patient p1, p2, p3;	// structures variables
	//struct Patient pat[MAX_PARTIENTS];

	printf("\n\n************ Struct examples ************\n\n");

	main_struct_nado();

	printf("\n\n************ Cat collection game ************\n\n");

	main_nado_catGame();

	return 0;
}

// 오브젝트: 메모리에 자리를 잡고 데이터가 저장돼 있으면, 그것을 오브젝트라 한다. 
//          C언어에서는 이 정도로 정리한다. 추상화된 개념으로서 object라고 부른다.
//			객체지향 언어(C++, java, python)를 공부할 때 더 자세히 공부한다. 
// 
// struct Patient를 보면, 
// name이라는 변수가 Patient라는 구조체의 맴버로 들어 있다. 
// <= 클럽의 맴버, Patient 구조체의 맴버로서 name이라는 변수가 있고, 
// height, weight, age라는 변수가 있다. 
//	<= 서로 자료형이 다르다.  
// 서로 자료형이 다르더라도 이렇게 묶어서 마치 하나의 새로운 자료형인 것처럼
// 프로그래밍할 수 있게 도와 주는 C언어의 문법이 바로 구조체이다. 
//
// struct Patient p1, p2, p3;
// <= 변수가 선언이 되고 있다. 
// struct Patient가 사용자가 필요해서 만든 새로운 자료형인 것처럼 
// 변수를 선언할 수가 있다. 
// p1, p2, p3는 structure variables라고 한다. (구조체 변수)
// 
// struct Patient pat[MAX_PARTIENTS]; 이런 식으로 배열을 사용할 수도 있다. 
// p1.name | p1.height | p1.weight | p1. age
// p2.name | p2.height | p2.weight | p2. age
// p3.name | p3.height | p3.weight | p3. age
// 
// Dot(.) is a structure member operator. 연산자이다. 
// <= 어떤 연산자? 구조체의 멤버에 접근할 수 있는 연산자이다. (구조체 멤버 연산자)
// 
// struct Patient p1, p2, p3; 이렇게 선언하는 순간,
// 메모리에 위와 같이 name, height, weight, age가 자리를 잡는다. 
// 멤버를 모두 포함하는 공간에 대해서 p1이 점유를 한다. <= p1 변수가 만들어진다. 
//                                                   데이터 오브젝트가 만들어진다. 
// p1의 각멤버에 접근하기 위해서는 dog(.) operator를 사용한다. 
// 
// 메모리 패딩 padding이라는 것이 있다. 뒤에서 설명.
// 
// template이른 개념도 알아 둬라. 
// <= 쿠기를 만드는 틀 정도로 생각하면 된다. 
//	structure를 선언하는 것, 
//  name, height, weight 등 변수의 집합, 
//  구조가 짜여진 덩어리라고 생각을 하면 된다. 
// 
// 위에서 보면, struct Patient {}; 가 쿠키 틀이 되는 것이다. 
// 
// struct Patient p1, p2, p3;에서 변수를 선언하면, 
// 그때 실제로 메모리를 갖게 되는 것이다. 
// <= 변수로 선언할 때 메모리에 실제로 존재하게 된다. 자리를 차지하게 된다. 
// 
// 마치 쿠키 틀로 꽝꽝꽝 찍어서 틀 모양의 쿠키를 만들 듯이 
// struct Patient {};의 메모리 구조(데이터의 구조)를 사용할 수 있는 
// 데이터 오브젝트들을 만들어 낸다. 
// 
// p1, p2, p3 이 변수들이 메모리에 자리를 잡는데, 
// 이 변수들은 구조체이기 때문에, 구조체의 멤버들이 각각 메모리를 차지하고 있는
// 여러 가지 데이터 오브젝트들이 복합적으로 합쳐져서 하나의 커다란 새로운 
// 사용자가 직접 만든 자료형인 것처럼 사용할 수 있게 도와 주는, 프로그래머를 도와주는
// 문법이 구조체이다. 
// 
// 템플릿이라는 개념과 구조체를 연관지어서 설명하는 경우가 많이 있다. 
// 
// p1, p2, p3 변수가 만들어지는 순간, 
// 이 구조체의 형태에 맞춰서 메모리에 (이렇게) 잡히게 된다. <= structure 그림 참조
// 
// 붕어빵 틀에 비유하기도 한다. 영어권에서는 쿠키 틀에 비유한다. 
// 
// C언어와 전산학에서 템플릿이 틀이라는 의미로 사용되기도 하지만, 
// C++에서는 tamplate이라는 문법이 따로 있다. 
// C++에서는 훨씬 더 구체적인 의미로 사용된다. 
// 
// 전반적인 의미는 틀이지만, 
// 문법적으로는, C언어에서 구조체가 템플릿으로서의 의미를 갖는다는 것과
// C++ 문법에서 템플릿이 무슨 기능을 갖는다는 의미는 조금 다르다. 
// 
// C++에서의 템플릿도 구조체가 아닌가라고 생각하면 조금 오해가 될 수 있다. 
// 
// 구조체가 왜 필요한지 기본적인 개념에 대해서 살펴 봤다. 