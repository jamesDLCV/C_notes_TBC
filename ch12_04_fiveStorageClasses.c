#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// Five storage classes
// 앞에서 변수의 영역와 연결 상태, 객체의 지속 기간 등과 같은 개념에 대해 설명을 했다. 
// 이를 통해, c언어로 프로그램을 할 때, 변수를 다양한 모델로, 다양한 용법으로, 
// 다양한 형태로 사용할 수 있다는 것을 알 수 있다. 
// 그렇다고 그 다양한 방법이 무한 가지로 있는 것은 아니고,
// c언어에서는 크게 다섯 가지 정도로 분류를 한다. 
// 
// 변수가 어디에 저장되는지에 따라서, 
// 어떤 특징을 가진 메모리 공간에 저장이 되는지에 따라서, 
// 다섯 가지 정도로 분류를 하는데 영어로 storage classes라고 한다. 
// 세부적인 내용은 표로 정리돼 있다. <= 표 참조. 
// static과 static이 아닌 것으로 크게 두 가지로 분류하기도 한다. 
// non-static은 자동 automatic; 레지스터 register
// static은 고정적, 내부 연결; 고정적, 외부 연결; 고정적, 연결 없음
//  
// 자동 변수 automatic: 지금까지 우리가 사용한 지역 변수는 모두 자동 변수이다. 
// 자동 변수라는 의미는 지속 기간과 영역을 프로그래머가 일일이 설정해 주는 것이 아니라,
// 꼭 필요한 기간에만 변수가 메모리에서 지속되고, 꼭 필요한 부분에서만 접근할 수 있도록
// (볼 수 있도록 visibility) 둘(지속 기간, 영역) 모두 자동으로 해결해 준다. 
// <= 편리하다. block 안에 설정한 지역 변수를 생각하면 된다. 
// 
// 
// 컴퓨터 작동 원리에서 cpu 안에 register가 있다, 임시 작업 공간이 있다고 설명했다. 
// 메모리는 cpu 밖에 분리돼 있다. 타이머리 storage이다. 
// register는 cpu 안에 있으므로 엄청 빠르다. 
// 
// 레지스터 변수는 지역 변수처럼 사용을 하는데, 변수 앞에 register 키워드를 사용하면, 
// 그 변수는 register로 올라갈 가능성이 높아진다. 
// 최근에는 컴파일러가 좋아져서 register를 안 붙여 줘도 register로 올려주기도 한다. 
// 여러 가지 최적화 부분은 복잡한 요소가 있어서, 딱 잘라서 말하기 어렵다. 
// 전문적으로 공부하고 싶으면, 컴파일러 공부를 좀 더 해야 한다. 
// 실무 프로그래밍에서 가속을 하고 싶을 때는, 이런 식으로 한다기보다는
// 캡슐을 이용한다든가, 병렬 처리, 분산 처리, GPU 가속 이런 것을 가지고 하는 게
// 최신 추세이다. 
// register 변수는 가속을 많이 할 거 같지만, 실질적으로 그렇게 많이 쓰이지는 않는다.
// C++에서는 인라인으로 어셈블리어를 집어 넣기도 한다. <= 이게 더 편할 수 있다. 
// 
// register 문법, 주의 사항을 살펴 볼 것이다. 
// 자동 변수와 register 변수는 묶어서 생각하면 편하다. 
// 
// 그 다음 static 변수들이 있다. (세 가지가 있다)
// static한 공간은 메모리에서 데이터 또는 BSS에 위치한다. 
// 지속 기간은 고정적이다. 
// 이들은 프로그램이 시작될 때 생겨나고 끝날 때까지 메모리에 계속 자리를 잡고 있다. 
// static을 고정적이라고 번역해 봤다. (우리 말에 더 와닿게 하려고)
// 메모리에 고정돼 있기 때문에 고정적이라고 했다.  
// 정적이라고 더 많이 쓰인다. 정적 변수라고 하면, 변수가 정지돼 있나? 
// 값이 안 변하나라고 오해를 할 수 있어서 고정적이라고 변역했다.
//   
// 고정적인 변수를 용법에 따라서 프로그래머에게 편리함을 더해 주기 위해서, 
// scope를 파일 안에 갖게 할 수도 있고, 블록 안에서만 살아 남게 할 수도 있다. 
// (표 참조)
// 
// Static with internal linkage는 파일 내부에서만 사용한다. 
// Static with external linkage일 경우에는, 외부로도 연결이 가능하다. 
// 
// 무엇이 내부고 외부냐?
// 컴파일러가 컴파일하는 단위가 파일이다. eg) 번역 단위의 내부, 번역 단위의 외부
// 컴파일러 입장도 어느 정도 이해해 둘 필요가 있다. 
// 
// 선언 방법은 뒤에서 예제와 함께 다시 살펴 본다. 
// 
// 복잡해 보이지만, 지속 기간, 영역, 연결 상태, 메모리에서의 위치의 개념을 이해하면,
// 그냥 하나의 흐름으로 충분히 이해할 수 있는 내용이다. 
// 
// 프로그래들이 편하게, 지속 기간, 영역, 연결 상태를 관리할 수 있도록 도와 주기 위해서,
// 스택이라는 공간을 만들고 거기에 저장을 하는 것이다. 
// 
// 컴파일러는 만든 사람들, 운영체제를 만든 사람들 입장에서 개념을 확장해서 접근해 보면,
// 다른 언어 공부할 때도 공부하는 속도가 아주 빨라진다. 
// 
// 다섯 가지 분류 외에 할당 메모리가 있다. 
// 컴퓨터를 사용할 때 실제로 많이 사용하는 부분이다. 
// 운영체제에게 특별히 나 이렇게 큰 공간이 필요해, 컴파일할 때는 사이즈가 얼마가 될지
// 몰랐지만, 지금 런타임에서 백 만 명에 대한 데이터를 저장할 공간이 필요하다고
// 요청하는 것이다. => 운영체제는 포인터만 던져 준다. 즉 식별자가 존재하지 않는다. 
// 최근의 언어에서는 이 할당 메모리도, 동적으로 사이즈가 변할 수 있는,  
// 재할당이 가능한, 마치 식별자가 있는 것처럼 사용할 수 있게 도와 준다. 
// 하지만 결국 내부적으로는 이렇게 식별자 없이 포인터만 던져 주는 식으로 작동한다. 
// 
// 동적 할당 메모리를 마치 변수처럼 사용할 수 있는 경우에는, 
// 저장 공간 분류를 위 다섯 가지를 따르게 된다. 
// 
// 지금 공부한 것이 여러분의 인식 능력을 키워 주고, 
// 장기적인 프로그래밍 능력을 키울 때 아주 중요한 부분이 된다. 
// 
// 할당 메모리는 저장 공간 분류에 포함이 되지는 않는다. 
// 
// 힙 메모리는 운영체제가 그때 그때 남는 공간을 던져 주는 형태가 된다. 
// 
// 어떤 언어도 이와 같이 사용된다는 것을 알아 두면 좋다. 
// 이후 코드 예제로 더 살펴 본다. 
//


int main() {
	// 코드 예제는 다음 강의에서 다룬다. 

	return 0;
}