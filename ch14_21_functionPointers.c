#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// Function Pointers, 함수 포인터의 원리
// 
// 함수가 메모리의 어디에 저장이 돼 있는지를 가리킬 때 사용하는 
// 함수 포인터에 대해서 살펴 본다. 
//
// 함수 포인터의 기본적인 선언 방법과 작동 원리를 
// 메모리 레이아웃과 연관지어서 살펴 보겠다. 

void f1() {
	return;
}

int f2(char i) {
	return i + 1;
}

int main() {
	
	void (*pf1)() = f1;
	//void (*pf1)() = &f1;	<= 된다. 

	int (*pf2)(char) = f2;

	(*pf1)();	// call f1 via pf1
	//pf1();				<= 된다. 

	int a = pf2('A');
	//int a = (*pf2)('A');

	printf("%d\n", a);	//66

	return 0;
}

// 일반적인 변수를 가리키는 포인터 변수를 선언할 때, 
// asterisk *를 사용했다. <= *pf1
// 
// 함수 포인터는 조금 더 복잡해 보이기는 하지만, 
// 결국은 다른 포인터처럼 주솟값을 저장하는 변수에 불과하다. 
// 
// 어떠한 함수의 주솟값을 저장할 수 있는지를 미리 지정해 주기 위해서
// void, (), int, (char) 같은 것들이 붙어 있다. 
//  <= void (*pf1)() = f1;
//     int (*pf2)(char) = f2;
// 
// 함수라고 하면 parameters에 무엇이 들어가는지와 반환 자료형이 무엇인지
// 이 두 가지가 중요하다고 이전 강의에서 언급했다. 
//  <= 함수의 입력이 무엇인지, 출력이 무엇인지가 중요하다.
//
	/*
	void f1() {
		return;
	}

	int f2(char i) {
		return i + 1;
	}
	 <= 함수의 parameter는 char i이고 반환되는 자료형은 int이다. 
	*/
// 
// 그래서 함수를 가리키는 포인터 변수를 선언할 때는, 
// 입력이 뭔지 반환값이 뭔지를 함께 지정을 해 줘야 선언을 할 수 있다. 
// 
// 변수에 대한 포인터에서 포인터 연산을 하기 위해 자료형의 크기를 미리 알아야 했던 것처럼
// 예) int* a에서 a++는 sizeof(int)만큼 주솟값을 증가시킨다. 
// 
// 일반적인 변수에 대한 포인터는 그 크기를 알아야 포인터 연산을 할 수 있다고 
// 앞 강의에서 언급했다. <= 중요하다! 
// 
// 마찬가지로 함수 포인터의 경우에도 parameter가 어떤 타입인지, 
// 반환값이 어떤 타입인지 미리 알고 있어야, 
// 나중에 그 function pointer를 통해서 
// 그 함수를 실제로 호출 혹은 실행시킬 수 있기 때문에 
// void (*pf1)() = f1;  
// int (*pf2)(char) = f2; <= 이런 형태로 선언한다. 
//  <= *pf1은 임의로 붙인 이름이다. 
//     변수명 짓 듯이 마음대로 지을 수 있다. 
//     어떤 변수이냐?
//     <= f1 이 함수가 메모리에 저장돼 있는 그 주솟값을 저장하는 변수이다. 
//        포인터라는 게 결국은 주솟값을 저장하는 변수이다. 
// 
// function pointer도 마찬가지로 주솟값을 저장하는 변수이다. 
// 단지 그 주소가 함수가 저장돼 있는 곳의 주소라서 좀 특이한 성질을 갖게 된다. 
// 아래 예제를 보자.
	/*
	void (*pf1)() = f1;
	//void (*pf1)() = &f1;

	int (*pf2)(char) = f2;
	 <= 앞에 자료형이 붙어 있고, 뒤에 괄호 안에 (char)이 들어 있다. 
	    parameters가 여러 개라면, 
		int (*pf3)(char, int, double)과 같이 넣어 줄 수 있다. 
	 <= *pf2 이 function pointer는 
	    int f2(char i) 이런 형태의 함수만 가리킬 수 있다. 

	(*pf1)();	// call f1 via pf1
	 <= function pointer를 통해서 (*pf1)() 함수를 실행시킬 수 있다. 
	    지금 *pf1이라는 포인터 변수가 가지고 있는 값은, 
		f1이라는 함수가 메모리에 위치해 있는 주솟값이다. 
		그래서 이 포인터를 통해서 함수를 실행시킬 수 있는 것이다. 
     <= f1 말고 다른 함수의 주솟값을 포인터에 넣었다가 실행시킬 수도 있고, 
	    실행을 한 번 시키고 바꿀 수도 있다. 
		여러 가지로 유연하게, 프로그래밍을 할 때, 사용할 수 있다. 
		<= 다음 강의에서 예제와 함께 소개한다. 

	<= 문법상 함수의 주소를 가지고 올 때, 
	   void (*pf1)() = f1;
	   void (*pf1)() = &f1;
	   f1에다가 ampersand &를 붙여도 되고 안 붙여도 된다. 

	어떤 측면에서 보면, void f1()의 f1이 함수의 이름이니까, 
	주소를 가져오기 위해서는 앞에다가 &를 붙여 주는 게 맞다고 생각할 수 있는데, 
	내부적으로는 함수의 이름 자체가 포인터이다. 
	함수라는 게 메모리의 어떤 공간에 저장이 돼 있고, 
	실행을 시킬 때 그 주소에 있는 코드를 실행시킨다는 개념이기 때문에, 
	이름 자체가 주소이다. 
	그러므로 &가 앞에 안 붙어도 주소이다. 
	 <= f1, &f1 문법상 두 가지가 다 허용이 된다. 
	    컴파일러가 두 가지 다 '주소를 가져 오려 한다'고 인식한다. 
    
	함수의 포인터를 통해서 함수를 실행시킬 때에도, 
	(*pf1)(); 처럼 pf1이 함수의 포인터이니까 indirection을 해 주고 
	그 다음에 parameter를 넣어 주고 실행시키는 게 맞다고 생각하는 관점이 있고, 
	두 번째로 함수는 이름 자체가 포인터이니까, 
	pf1()처럼 뒤에 괄호만 붙여도 실행이 되는 게 맞다라는 관점이 있다. 
	따라서, 
	(*pf1)();
	pf1();		<= 이 두 가지 경우 모두 실행이 된다. 
	
	int (*pf2)(char) = f2;
	int a = pf2('A');	
	<= 이 경우는 pf2를 통해서 f2라는 함수를 실행시키는데, 
	   parameter는 'A'이고, 반환값은 int a이다. 
    int a = (*pf2)('A');
	<= 이 경우는 pf2를 indirection한 후 괄호를 해 주고   
	   parameter를 넣어 주고 실행을 시킨다. 

	<= function pointer pf2만 가지고도 실행을 시킬 수 있고, 
	   *를 붙여서 indirection한 후 실행을 시킬 수도 있다. 

	printf("%d\n", a);	//66
	*/
	//  
//  
// 기본적인 사용법은 매우 간단하다. 
// 좀 더 function pointer답게 프로그래밍하는 방법은 이어지는 강의에서 다룬다. 
// 
// 어떻게 이렇게 작동할 수 있는지 
// 또 함수 포인터의 성질에 대해서 조금 더 살펴 보겠다. 
// 
// 이전 강의에서 메모리 레이아웃을 스택과 힙 위주로 공부했었다. 
// Text Segment에 대해서 좀 더 알아 보자. 
// 
// 어떤 프로그램을 작성하고, 컴파일을 하면, 실행 파일이 만들어지고, 
// 실행 파일은 하드 디스크에 저장이 된다. 
// 운영체제에게 그 실행 파일을 실행하라고 요청을 하면, 
// 운영체제가 하는 일은 프로그램 자체를 메모리에 복사해서 올려 줘야 한다. 
// 그 프로그램 코드 자체가 저장되는 곳을 TEXT Segment라고 부른다. 
// 
// TEXT segment의 특징이 여러 가지가 있는데, 
// Read Only 읽기 전용이라는 측면에 대해서 이전 강의에서 소개했다. 
// 이와 관련해서 실수할 수 있는 부분이, 문자열과 관련된 것이었다. 
// 
// const char* message = "Banana";
// <= 배열을 선언해서 거기에다가 문자열의 내용을 복사하지 않고, 
//    이렇게 "Banana" 문자열 리터럴에 대한 주소만 가지고 있을 경우, 
//    이 message라는 포인터를 통해서 강제로 "Banana"가 저장되어 있는 
//    TEXT segment 어디엔가의 메모리에 접근해서 값을 바꾸려고 시도하면, 
//    런타임 에러가 발생함을 앞에서 살펴 봤다. 
// 
// 디버거를 통해서 실제로 메모리를 들여다 보면서, 
// 이러한 문자열 리터럴이 TEXT segment 쪽 어딘가에 저장이 된다는 것을 확인했다. 
// 
// 결과적으로 이런 형태로 포인터만 가지고 문자열 리터럴에 대한 주소를 가지고 있을 때는,
// const로 지정을 해 주는 것이 안전하는 문법적 측면도 언급했다. 
// 
// 그런데 message라는 포인터 변수 자체는 stack에 저장돼 있다. 
// 마찬가지로 
// void (*f_ptr)() = func;
// <= function pointer도 function pointer 자체는 주솟값을 저장하는 변수이다. 
//    따라서, 
//    printf("%lld\n", (long long)&message);
//    printf("%lld\n", (long long)&f_ptr);
//    <= &message와 &f_ptr의 주소를 출력해 보면 
//       모두 stack에 쪽 저장돼 있음을 확인할 수 있다.
// 하지만,
// printf("%lld\n", (long long)message);
//  <= message라는 포인터 변수가 가지고 있는 주소값 자체를 출력해 본다. 
// printf("%lld\n", (long long)f_ptr);
//  <= f_ptr(function pointer)가 가지고 있는 주소값 자체를 출력해 본다. 
// printf("%lld\n", (long long)main);
//  <= main() 함수의 이름(main이라는 인식자) 자체도 주솟값이다. 주곳값처럼 사용된다. 
//     function pointer처럼 사용될 수 있다. 
// <= 이 세 개는 출력을 해 보면, TEXT segment에 위치한다. 
//	  message라는 포인터 변수가 가리키고 있는 
//    "Banana"라는 문자열 리터럴이 저장돼 있는 곳, 
//    f_ptr이라는 function pointer가 가리키고 있는 func라는 함수가 저장돼 있는 곳,
//    main이라는 이름을 가진 함수가 저장돼 있는 곳은
//    모두 TEXT segment이기 때문이다.  
//  
// 함수를 실행시킨다는 것은, 결국 이 function을 찾아서 
// (그 함수가 저장돼 있는 코드를 찾아서),
// 그 내용을 실행시키는 방식으로 작동한다. 
//   
// 프로그래머는 함수의 이름을 이용해서 프로그램을 작성하지만 
// 컴파일러는 이름(식별자)를 메모리에서의 주소로 번역한다.
// 즉, 함수를 실행시킨다는 것은 
// 메모리에서 함수의 주소 위치에 저장되어 있는 명령어들을 순차적으로 수행한다는 의미이다. 
//  
// 함수 포인터의 기본적인 사용 방법과 
// 작동 원리(내부적으로 어떻게 작동이 되는지)를 메모리 레이아웃과 연관지어서 살펴 봤다. 